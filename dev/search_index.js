var documenterSearchIndex = {"docs":
[{"location":"direct/direct_check/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Применим метод пробной функции или контрольной невязки. Это позволит сравнивать решение, получаемое нашей схемой, с аналитическим решением, даже если мы не можем найти аналитическое решение исходного уравнения.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Идея проверки заключается в выборе некоторой известной пробной функции, например, g(xt), которая не является решением исходного уравнения. Подставив пробную функцию уравнение, оно не обращается в тождество. Если преобразовать уравнение путем вычитания невязки, полученной в прошлом действии, то мы получим новое уравнение, для которого уже g(xt) –- решение.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"После этого, мы решаем решаем модифицированное уравнение с помощью нашей схемы, в которой нужно лишь подправить функцию возвращающую вектор правой части –- нужно дополнительно вычесть невязку, формулу для которой мы нашли аналитически.","category":"page"},{"location":"direct/direct_check/#Алгоритм-1","page":"Проверка корректности решения прямой задачи","title":"Алгоритм","text":"","category":"section"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим следующую пробную функцию g(xt) = (1-2t) sin(pi x). Найдем её производные:","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Подстановка пробной функции в исходной уравнение (см. Постановка обратной задачи), позволит нам определить g_d","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 -\n    fracpartial upartial t = -u fracpartial upartial x +\n    q(x)u - g_d(xt) quad x in (01) quad t in (0T \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T \n    u(xt) = u_init(x) qquad x in 01 t = 0\nendaligned\nright","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Найдем решение следующим образом:","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) +\n        (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1 \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m) \n        mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)\n        t_mBig)right  mathbftextbfw_1 = \n        qquadqquadqquadqquadquad = mathbftextbff \n        Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big) -\n        g_d(mathbfX_nfract_m + 1 + t_m2)\n    endaligned","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"где g_d(mathbfX_n) — значения g_d на сетке x_1 x_x ldots x_N, т.е. на сетке mathbfX_n без граничных точек. Решение будем находить с помощью функции solve, но перед этим сконструируем функцию правой части и её якобиан и передадим их в качестве аргументов.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Такая проверка корректности решения применяется в unit тесте \"tests/direct_with_model.jl\". Здесь мы сделаем include, Literate.jl включит текст теста в md файл.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Перед запуском, необходимо подключить все пакеты, что используются при тестировании.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"EditURL = \"<unknown>/src/examples/dt_direct.jl\"","category":"page"},{"location":"direct/direct_check/#Непосредственная-реализация-проверки-1","page":"Проверка корректности решения прямой задачи","title":"Непосредственная реализация проверки","text":"","category":"section"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Тест проверяет корректность решения прямой задачи. Алгоритм описан в /docs/src/direct/direct_check.md Возвращает решение, аналитическое решение, сетку по X, сетку по T.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"using NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing ForwardDiff;\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим параметры для прямой задачи","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u_l(t) = 0;                     # ГУ удовлетворяющие модельной функции\nu_r(t) = 0;                     # ГУ удовлетворяющие модельной функции\nqf(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 1;                   # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ= u_l.(Tₘ);                  # Сеточные значения левого  ГУ\nurₘ= u_r.(Tₘ);                  # Сеточные значения правого ГУ\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим модельную функцию и невязку, получаемую после подстановки g в исходное уравнение","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"function g(x, m)\n    t = Tₘ[m]\n    (1 - 2t)*sin(π*x)\nend\nfunction g_d(x::Real, m::Int)\n    t = Tₘ[m];\n    - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - qf(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x)\nend\n\ny₀ = g.(Xₙ, 1);               # Начальные условия\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Модельное решение найденное с помощью известного аналитического решения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u_model = [ g(x, m) for x in Xₙ, m in 1:M+1];\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"function RP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ)\n    d = [ g_d(x, m) for x in Xₙ[2:N] ]\n    NonLinearReactionAdvectionDiffusionWithFrontData.directRP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) - d\nend","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Хоть мы и конструируем якобиан с помощью автоматического дифференцирования, примите во внимание, что Якобиан f_y при добавлении g_d останется без изменений, т.к. g_d зависит только от xt. То, что он не зависит от добавления g_d можно убедиться изменением порядка этих двух строк, ну а так же на бумаге.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"j(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) = ForwardDiff.jacobian( z -> RP(z, m, Xₙ, N, ε, ulₘ, urₘ, qₙ), y)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"С использованием автоматического дифференцирования","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, j);\n@test all(isapprox.(u_model, u, atol = 0.01))","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"С использованием трехдиагонального якобиана","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n(u, u_model, Xₙ, Tₘ)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(u, Xₙ, Tₘ, dd, dd, dd, d, d, u_model; name = \"dicrect_check.gif\")","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"err = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"This page was generated using Literate.jl.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/examples/dt_direct.jl\"","category":"page"},{"location":"direct/direct_check/#Непосредственная-реализация-проверки-2","page":"Проверка корректности решения прямой задачи","title":"Непосредственная реализация проверки","text":"","category":"section"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Тест проверяет корректность решения прямой задачи. Алгоритм описан в /docs/src/direct/direct_check.md Возвращает решение, аналитическое решение, сетку по X, сетку по T.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"using NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing ForwardDiff;\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим параметры для прямой задачи","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u_l(t) = 0;                     # ГУ удовлетворяющие модельной функции\nu_r(t) = 0;                     # ГУ удовлетворяющие модельной функции\nqf(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 1;                   # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ= u_l.(Tₘ);                  # Сеточные значения левого  ГУ\nurₘ= u_r.(Tₘ);                  # Сеточные значения правого ГУ\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим модельную функцию и невязку, получаемую после подстановки g в исходное уравнение","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"function g(x, m)\n    t = Tₘ[m]\n    (1 - 2t)*sin(π*x)\nend\nfunction g_d(x::Real, m::Int)\n    t = Tₘ[m];\n    - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - qf(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x)\nend\n\ny₀ = g.(Xₙ, 1);               # Начальные условия\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Модельное решение найденное с помощью известного аналитического решения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u_model = [ g(x, m) for x in Xₙ, m in 1:M+1];\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"function RP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ)\n    d = [ g_d(x, m) for x in Xₙ[2:N] ]\n    NonLinearReactionAdvectionDiffusionWithFrontData.directRP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) - d\nend","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Хоть мы и конструируем якобиан с помощью автоматического дифференцирования, примите во внимание, что Якобиан f_y при добавлении g_d останется без изменений, т.к. g_d зависит только от xt. То, что он не зависит от добавления g_d можно убедиться изменением порядка этих двух строк, ну а так же на бумаге.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"j(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) = ForwardDiff.jacobian( z -> RP(z, m, Xₙ, N, ε, ulₘ, urₘ, qₙ), y)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"С использованием автоматического дифференцирования","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, j);\n@test all(isapprox.(u_model, u, atol = 0.01))","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"С использованием трехдиагонального якобиана","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n(u, u_model, Xₙ, Tₘ)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(u, Xₙ, Tₘ, dd, dd, dd, d, d, u_model; name = \"dicrect_check.gif\")","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"err = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"page"},{"location":"direct/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/examples/de_direct.jl\"","category":"page"},{"location":"generated/docexample_direct/#Примеры-1","page":"Примеры","title":"Примеры","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"На этой странице мы делаем include примеров, которые лежат в корневом каталоге пакета в папке \"examples/\".","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Literate.jl включает текст этих примеров и в md файл.","category":"page"},{"location":"generated/docexample_direct/#de_1-1","page":"Примеры","title":"Пример №1, подробный, статическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"вручную задаются входные параметры,\nрешается прямая задача,\nгенерируются экспериментальные данные.","category":"page"},{"location":"generated/docexample_direct/#Решение-прямой-задачи-1","page":"Примеры","title":"Решение прямой задачи","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Здесь мы зададим параметры вручную, дав комментарии о них. После, во всех следующих примерах, будем задавать параметры с помощью стандартной функции NonLinearReactionAdvectionDiffusionWithFrontData.dparams","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\n\nu_l(t) = -8 + sin(2*π / T * t); # Прямая задача может быть с неоднородными ГУ\nu_r(t) =  4 +4sin(-2*π / T * t);# Но в дальнейшем, будем использовать только однородные.\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый известный коэффициент, который\n                                # и будем определять имея априорную информацию.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.28;                # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =     qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nu₀ = u_init.(Xₙ);               # Начальные условия\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Все массивы передаются внутрь функции solve полностью, вместе с граничными точками. Внутри, они локально модифицируются, и на вход NonLinearReactionAdvectionDiffusionWithFrontData.directRP, NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y подаются без граничных точек.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"u, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Генерация-априорной-информации-1","page":"Примеры","title":"Генерация априорной информации","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Здесь у нас все просто, сетка статическая, жизнь прекрасна.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                      # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true);     # Нужно сигнализировать, о интегрировании в\n                                                                        # обратном направлении вдоль оси ``X``.\n                                                                        # Ответ нам вернут в обычном направлении.\nϕ       = Φ(ϕl, ϕr, N, M);                                              # Полуразность вырожденных корней\nf1_data = f1(ϕ, u, Xₙ, N, M);                                           # Положение переходного слоя\nf2_data = f2(f1_data, u, Xₙ, N, M);                                     # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#Визуализация-1","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Мы не можем строить большие анимации на стороне Travis-a. Если мы на CI, то будем рисовать только 10 кадров. Если мы генерируем документацию локально, то рисуем 80 кадров.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"isTravis = in(\"Travis\", keys(ENV))\nftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Запись gif одного только решения","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"make_gif(u, XX, Tₘ; name=\"direct_example.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Запись только mp4 вместе с вырожденными корнями и переходным слоем.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"make_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data;\n         name=\"direct_with_f1_f2_example.mp4\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_2-1","page":"Примеры","title":"Пример №2, краткий, стандартные параметры","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"получаем стандартные входные параметры,\nрешается прямая задача,\nгенерируются экспериментальные данные.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Только в отличии от Подробного примера №1 будем пользоваться функциями-сокращениями.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Этот файл будет использоваться в тестировании.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Задаем параметры с помощью стандартной функции NonLinearReactionAdvectionDiffusionWithFrontData.dparams","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\n\na, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀ = NonLinearReactionAdvectionDiffusionWithFrontData.dparams();\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"u, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Генерируем экспериментальные данные функцией NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ϕl, ϕr, ϕ, f1_data, f2_data = NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data(u, Xₙ, N, Tₘ, M, qₙ, ulₘ, urₘ);\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для стандартных данных.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"make_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"direct_with_f1_f2_example.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_3-1","page":"Примеры","title":"Пример №3, развернуты, динамическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"вручную задаём параметры для динамической сетки,\nрешается прямая задача,\nгенерируются экспериментальные данные на динамической сетке.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: shishkin_mesh;\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Заданием-параметров-для-динамической-сетки-1","page":"Примеры","title":"Заданием параметров для динамической сетки","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"u_l(t) = -8;                    # ГУ\nu_r(t) =  4;                    #\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.01;                       # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.42;                # Область по T\nx_tp = 0.12;                    # Положение переходного слоя\nM = 500;                        # Кол-во разбиений по X, T\nτ = (T-t₀)/M;                   # шаг по T\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Использование динамической кусочноравномерно сетки","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Новое поведение будет реализоваться с помощью передачи функции создания сетки внутрь solve в качестве аргумента. Эта функция должна принимать только один аргумент — положение переходного слоя и формировать соответствующую сетку. В пакете есть формирование кусочно-равномерной сетки со сгущениями на границе и на переходном слое. Создадим замыкание этой функции, которое будет иметь нужную сигнатуру.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"mshfrm(x_tp) = shishkin_mesh(a, b, x_tp, ε, 40, 0.5, 1.0, 1.0, 0.25);\nXₙ = mshfrm(x_tp); ;                            # Сетка по Х\nN  = length(Xₙ) - 1                             # Примем за N длину сетки, что получилась в итоге.\nqₙ =    qf.(Xₙ);                                # Сеточные значения коэффициента линейного усиления\nu₀ = u_init.(Xₙ, ε=ε, x_tp = x_tp);             # Начальные условия\n\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, create_mesh = mshfrm);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Генерация-априорной-информации-2","page":"Примеры","title":"Генерация априорной информации","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Полуразность вырожденных корней\nϕ       = apply_on_dynamic_mesh(ϕ, XX, N, M);                       # Аппроксимация на переменную сетку\nϕl      = apply_on_dynamic_mesh(ϕl, XX, N, M);                      # Аппроксимация на переменную сетку\nϕr      = apply_on_dynamic_mesh(ϕr, XX, N, M);                      # Аппроксимация на переменную сетку\nf1_data = f1(ϕ, u, XX, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, XX, N, M);                                 # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для стандартных данных.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ftw = [1; 2:div(M+1, 80):M+1];\nmake_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"direct_with_f1_f2_example.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_4-1","page":"Примеры","title":"Пример №4, краткий, динамическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Делаем тоже самое, что в развернотом примере, только с использованием функций сокращений и стандартных параметров.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: shishkin_mesh;\n\n# Задача параметров и решение в коротком виде\na, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀, mshfrm_std = NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform();\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, create_mesh = mshfrm_std);\nnothing #hide\n\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Полуразность вырожденных корней\nϕ       = apply_on_dynamic_mesh(ϕ, XX, N, M);                       # Аппроксимация на переменную сетку\nϕl      = apply_on_dynamic_mesh(ϕl, XX, N, M);                      # Аппроксимация на переменную сетку\nϕr      = apply_on_dynamic_mesh(ϕr, XX, N, M);                      # Аппроксимация на переменную сетку\nf1_data = f1(ϕ, u, XX, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, XX, N, M);                                 # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для стандартных данных динамической сетке.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ftw = [1; 2:div(M+1, 80):M+1];\nmake_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"direct_with_f1_f2_example.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"This page was generated using Literate.jl.","category":"page"},{"location":"direct/experimental_data/#Генерация-экспериментальной-информации-1","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"","category":"section"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Левое вырожденное решение","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"left\nbeginaligned\n     fracd phi^ldx = q(x) quad x in (0 1 \n     phi^l(0) = u_l\nendaligned\nright","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Правое вырожденное решение","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"left\nbeginaligned\n     fracd phi^rdx = q(x) quad x in 0 1) \n     phi^r(1) = u_r\nendaligned\nright","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Пересечение функции Phi(x) = abs(phi^l - phi^r)2 + phi^l с функцией u(x t) и будет определять положение переходного слоя x_tp = f1(t) и значение функции u(x_tp(t)t) = f2(t) в этой точке.","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Для поиска положения переходного слоя x_tp в момент времени t0 найдем x при котором Phi(x) - u(x t0) = 0.","category":"page"},{"location":"direct/direct/#Алгоритм-решения-прямой-задачи-1","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"","category":"section"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"Если записать систему в следующем виде:","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbff  (mathbftextbfyt) quad t in (t_0T\n        mathbftextbfy(t_0) = mathbftextbfy_init\n    endaligned\n    right","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"где","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"    beginaligned\n        mathbftextbfy = big(u_1  u_2   ldots  u_N - 1 big)^T \n        mathbftextbff = big(f_1  f_2  ldots  f_N - 1big)^T \n        mathbftextbfy_init = big(u_init (x_1)  u_init (x_2)  ldots  u_init (x_N - 1) big)^T\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"u_textinit(x_n) вычисляется с помощью u_init(x).","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"То текущая функция определяет вектор-функцию mathbftextbff следующим образом:","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"    beginaligned\n        f_1 =       varepsilon dfracy_2        - 2y_1       + u_left(t)h^2 + y_1       dfracy_2        - u_left(t)2h - q(x_1) y_1 \n        f_n =       varepsilon dfracy_n + 1    - 2y_n       + y_n - 1h^2   + y_n       dfracy_n + 1    - y_n - 12h   - q(x_n) u_n quad n=overline2 N-2 \n        f_N - 1 = varepsilon dfracu_right(t) - 2y_N - 1 + y_N - 2h^2   + y_N - 1 dfracu_right(t) - y_N - 22h   - q(x_N-1) y_N-1\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"На каждом временном шаге, решение находится как:","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"где W_1 находится из","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"beginaligned\n    leftmathbftextbfE - alpha  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n    qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big)\nendaligned","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"mathbff_mathbfy(mathbfy(t_m) t_m) — якобиан функции NonLinearReactionAdvectionDiffusionWithFrontData.directRP по вектору y (в момент времени t_m) в момент времени t_m. Эта матрица Якоби имеет следущие ненулевые элементы.","category":"page"},{"location":"direct/direct/#","page":"Алгоритм решения прямой задачи","title":"Алгоритм решения прямой задачи","text":"beginaligned\n     left(f_yright)_11   equiv  fracpartial f_1partial y_1  =  varepsilondfrac-2h^2 - dfracy_2 - u_left(t)2h + q(x_1) \n\n      left(f_yright)_nn - 1   equiv  fracpartial f_npartial y_n - 1  =  varepsilon dfrac1h^2 + dfracy_n2h quad n=overline2 N-1\n\n      left(f_yright)_nn   equiv  fracpartial f_npartial y_n  =   -varepsilon dfrac2h^2 - dfracy_n+1 - y_n-12h + q(x_n) quad n=overline2 N-2\n\n      left(f_yright)_nn + 1   equiv  fracpartial f_npartial y_n + 1  =  varepsilon dfrac1h^2 - dfracy_n2h quad n=overline1 N-2\n\n      left(f_yright)_N - 1N - 1   equiv  fracpartial f_N - 1partial y_N - 1  =   varepsilon dfrac-2h^2 - dfracu_right(t) - y_N - 22h + q(x_N)\nendaligned","category":"page"},{"location":"adjoint/adjoint_check/#Проверка-решения-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Проверка решения сопряженной задачи","text":"","category":"section"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Подставим найденные производные в исходное уравнение (см.Сопряженная задача) и перенеся все в правую часть, определим g_d.","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"g_d(xt) = 2 sin(pi x) - ( - varepsilon pi^2 (1 - 2t) sin(pi x) )+\nu(xt) pi (1 - 2t) cos(pi x) + q(x) (1 - 2t) sin(pi x) - 2 delta( x - f_1(t) ) (u(xt) - f_2(t))","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"left\nbeginaligned\n     fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 + u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) - g_d quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/adjoint_check.jl\". Файл содержит один @testset, внутри него реализовано решение вышеописанной системы, проверка его корректности через @test. А так же, @testset возвращает ψ, ψ_model, Xₙ, Tₘ, что соответствует решению, аналитическому решению, сетке по X, T.","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"using Test\nψ, ψ_model, Xₙ, Tₘ = include(\"../../../test/adjoint_check.jl\")\nnothing #hide","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Анимация решения нарисуем с неравномерным течением времени: первые 80 кадров, а потом каждый десятый.","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(ψ, Xₙ, Tₘ[end:-1:1], dd, dd, dd, d, d, ψ_model;\n            name=\"adjoint_check.gif\", label=\"\\\\psi\", frames_to_write=[1:80; 81:10:length(Tₘ)], convert2mp4=true)","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"using LaTeXStrings, Plots\nerr = ψ .- ψ_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"functional/functional/#Вычисление-функционала-1","page":"Функционал","title":"Вычисление функционала","text":"","category":"section"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"Jq = intlimits^T_0 left( u(f_1(t) t q) - f_2(t) right)^2 dt + alpha\nintlimits_0^1 left( q(x) right)^2 dx","category":"page"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"где f_1 f_2 — априорная информация, которая была единожды вычислена до итерационного процесса, при известном q(x), alpha — параметр регуляризации, пока равный нулю.","category":"page"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"После вычисления сеточных значения u(xt q^s) на сетках Xₙ Tₘ нам необходимо найти значение искомой функции на переходном слое u( f_1(t) t q).","category":"page"},{"location":"functional/functional/#Вычисление-градиента-функционала-1","page":"Функционал","title":"Вычисление градиента функционала","text":"","category":"section"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"Jq^s(x) = intlimits_0^T u^(s) (xt) psi^(s)(xt) dt","category":"page"},{"location":"reference/#Справочник-1","page":"Справочник","title":"Справочник","text":"","category":"section"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]","category":"page"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","text":"module NonLinearReactionAdvectionDiffusionWithFrontData\n\nПакет реализует исследование в рамках гранта РФФИ #20-31-70016 \"Численные методы решения обратных задач для нелинейных сингулярно возмущённых уравнений типа реакция-диффузия-адвекция с данными о положении фронта реакции\".\n\nАвтор исходного кода пакета:\n\nАндрей Борзунов, Кафедра математики физического факультета МГУ им. Ломоносова.\n\nИсполнители гранта:\n\nМельникова Алина Александровна\nЛевашова Наталия Тимуровна\nЛукьяненко Дмитрий Витальевич (Руководитель)\nБыцюра Светлана Владимировна\nБорзунов Андрей Анатольевич\nИсаев Темур Фуркатович\nАргун Рауль Ларикович\nГорбачев Александр Викторович\n\nДокументация: https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl\n\n\n\n\n\n","category":"module"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J","text":"J(uˢ::Matrix, Xₙ::Array, N::Int,\n  Tₘ::Vector, M::Int,\n  f1::Vector, f2::Vector,\n  qₙˢ::Vector, α::Real = 0.0) -> Real\n\nВычисляет функционал J(mathbfx) = int_0^T left( u(f_1(t) t q^s) - f_2(t) right)^2 + alpha int_0^1 q^2(x) dx.\n\nИспользует f2 для вычисления u(f_1(t) t) и после по формуле трапеций.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J_q","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J_q","text":"J_q(uˢ::Matrix, ψˢ::Matrix,\n    Xₙ::Array, N::Int,\n    Tₘ::Vector, M::Int) -> Vector\n\nВычисляет градиент J_q(x) = int_0^T u^s(x t) psi^s(x t) dt.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.apply_on_dynamic_mesh-Tuple{Array{T,2} where T,Array{T,2} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.apply_on_dynamic_mesh","text":"apply_on_dynamic_mesh(ϕ::Matrix, XX::Matrix,\n                  N::Int, M::Int) -> Matrix\n\nАппроксимирует ϕ на диномичски изменяющуюся на каждом временном шаге сетку XX.\n\nФункции phidetermination определяют вырожденные корни на стартовой сетке. Φ проиозводит линейные операции над векторами на каждом временном шаге. Поэтому если в расчетах была использована динамическая сетка, то нужно переопределить ϕ на этой динамической сетке.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.delta","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.delta","text":"delta(x, Xₙ, x₀ = 0) -> ::Real\n\nВычисляет конечно разностную аппроксимацию дельта функции delta(x x₀) на сетке Xₙ исходя из intlimits_a^b delta(x x₀) dx = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f1-Tuple{Array{T,2} where T,Array{T,2} where T,Array,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f1","text":"f1(ϕ::Matrix, u::Matrix, Xₙ::Array, N::Int, M::Int) -> Vector\n\nНаходит положение переходного слоя f_1(t) = x_tp(t) путем поиска точки пересечения аргумента, при котором пересекаются u(xt) и ϕ(x).\n\nТочка пересечения находится путем интерполяции функции обратной к u(xt) - ϕ(x) = 0, передавай аргументы в инвертированном виде в find_f_zeros.\n\nSee also: find_f_zeros\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f2-Tuple{Array{T,1} where T,Array{T,2} where T,Array,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f2","text":"f2(ϕ::Matrix, u::Matrix, Xₙ::Array, N::Int, M::Int) -> Vector\n\nНаходит значение искомой функции на переходном слое f_2(t) = u(x_tp t). Находится путем интерполяции функции u(x - f1(t) t) = 0.\n\nSee also: find_f_zeros\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","text":"make_gif(u::Matrix, Xₙ::Vector, Tₘ::Vector,\n              ϕ_l::Matrix = missings(2), ϕ_r::Matrix = missings(2),\n              f1::Vector = missings(2), f2::Vector = missings(2),\n              analitical = nothing;\n              frames_to_write::Int = -1,\n              name = \"solution.gif\",\n              convert2mp4 = false)\n\nРисует gif анимацию решения. вплоть по frames_to_write-ый кадр, сохраняет как \"results/name\".\n\nТак же рисует аналитическое решение analitic(x,t), если таково передано. label::String — LaTeX строка подписи искомой функции с экранирование спец. символов.\n\ntip: Tip\nPass an empty string to avoid saving at disk.\n\nTODO: Fix doc\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_minimzation_gif-Tuple{Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_minimzation_gif","text":"make_minimzation_gif(Js::Vector, Qs::Matrix,\n                     qₙ::Vector, Xₙ::Vector;\n                     frames_to_write::Vector = Vector(),\n                     name = \"solution.gif\", convert2mp4 = false,\n                     β::Real = 0.0)\n\nСохраняет анимацию процесса минимизации.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","text":"make_plot(u::Matrix, Xₙ::Vector, Tₘ::Vector, m::Int,\n               ϕ_l::Matrix = missings(2), ϕ_r::Matrix = missings(2),\n               f1::Vector = missings(2), f2::Vector = missings(2),\n               analitical = nothing;\n               label::String = \"u\")\n\nРисует m-ый кадр решения u. Xₙ, Tₘ — сетки. ϕ_l, ϕ_r — вырожденные решения. f1, f2 — сгенерированные априорные данные. analitical — или функция или сеточные значения аналитического решения. label::String — LaTeX строка подписи искомой функции с экранирование спец. символов.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.minimize-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Any,Any,Array{T,1} where T,Any,Any,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.minimize","text":"minimize(q₀::Vector, u₀::Vector,\n         ulₘ::Vector, urₘ::Vector,\n         ψ₀::Vector,\n         ψl::Vector, ψr::Vector,\n         Xₙ, N,\n         Tₘ::Vector, M,\n         ε,\n         f1_data::Vector, f2_data::Vector;\n         S::Int = 10,\n         β::Real = 0.01,\n         w::Real = 0.0001,\n         create_mesh::Function = x -> [NaN, NaN])  -> Vector, Vector, Matrix\n\nВернет qˢ на оригинальной сетке Xₙ[:,1].\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination","text":"phidetermination(q::Vector, ub::Vector,\n                 Xₙ::Vector, N::Int,\n                 Tₘ::Vector, M::Int;\n                 reverseX = false)\n\nРешает ОДУ для нахождения вырожденного корня.\n\nreverseX флаг обозначающий направления интегрирования по оси X.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve","text":"solve(y₀::Vector, Xₙ::Vector, N::Int,\n      Tₘ::Vector, M::Int,\n      ε::Real, ulₘ::Vector, urₘ::Vector,\n      qₙ::Vector,\n      RP::Function = directRP,\n      jac::Function = ∂directRP_∂y;\n      α::Complex = complex(0.5, 0.5),\n      create_mesh::Function = x -> [NaN, NaN]) -> Matrix, Matrix, Vector\n\nФункция, которая находит решение прямой задачи с помощью одностадийной схемы Розенброка с комплексным коэффициентом.\n\nArguments\n\ny₀::Vector:         Сеточные значения начального условия.\nXₙ::Vector:         Пространственная сетка по X.\nN::Int:             Число интервалов сетки по X.\nTₘ::Vector:         Пространственная сетка по t.\nM::Int:             Число интервалов сетки по t.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Function:      Сеточные значения левого ГУ.\nurₘ::Function:      Сеточные значения правого ГУ.\nqₙ::Vector:         Сеточные значения \"неоднородности\", см. постановку задачи.\nRP::Function:       Функция вычисления вектора правой части — directRP.\njac::Function:      Якобиан правой части по вектору y — ∂DRP_∂y.\nα::Complex:         Коэффициент схемы. При α = 0 — схема Эйлера, при α = complex(0.5, 0.5) — схема Розенброка с комплексным коэффициентом.\ncreate_mesh::Function: Принимает один аргумент x_tp положение переходного слоя и формирует подходяющую сетку.\n\nReturn\n\nТройку:     - Матрицу размера (N+1 M+1), содержащую значения искомой функции на сетках X_n T_m,.     - Матрицу размера (N+1 M+1), содержащую значения стеки X_n на каждом моменте времени.     - Вектора размера M+1, содержащий координаты положения переходного слоя в каждый момент времени.\n\ninfo: Info\nXₙ, qₙ, y₀     векторы размера N+1!\nTₘ, ulₘ, urₘ   векторы размера M+1!\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","text":"warning: Warning\nМассивы Xₙ, Tₘ, u, f1, f2 Передаются как есть! Они переварачиваются внутри функции локально.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.u_init-Tuple{Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.u_init","text":"u_init(x::Real; ε::Real = 0.2, x_tp = 0.15) -> Real\n\nНачальные условия в виде (x^2 - x -2) -6 tanh( -3 xi), где xi = fracx - x_tpε. x_tp — положение внутрннего переходного слоя.\n\nnote: Note\nГраничные условия для этих начальных условий должны быть заданы как (-8, 4).\n\nnote: Note\nВы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.\n\nExample\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)\n11-element Array{Float64,1}:\n -7.868156688432881\n -5.900893714323723\n  1.650893714323725\n  3.6581566884328813\n  3.753366656356917\n  3.749669571706625\n  3.7599835485135173\n  3.7899991809276505\n  3.839999959220786\n  3.909999997969723\n  3.999999999898918\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.Φ-Tuple{Array{T,2} where T,Array{T,2} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.Φ","text":"Φ(ϕ_l::Matrix, ϕ_r::Matrix, N::Int, M::Int) -> ::Vector\n\nВычисляет значение функции на переходном слое на каждом шаге по времени m phi_l^m - phi_r^m2 с помощью матриц вырожденных решений phi_l и phi_r вырожденного корня.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.ARP_y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.ARP_y","text":"\"     ARP_y(y::Vector, m::Int,           Xₙ::Vector, N::Int,           Tₘ::Vector, M::Int,           ε::Real,           ulₘ::Vector, urₘ::Vector,           qₙ::Vector,           Uₙₘ::Matrix, f1::Vector, f2::Vector) ->           (::Vector, ::Vector, ::Vector)\n\nВозращает три диагонали якоибана правой части сопряженной задачи. Входные параметры полностью аналогичны adjointRP.\n\nReturn\n\nВозвращает три вектора dl, d, dl элементов якоибана. Нижняя и верхняя диагонали длины N-2, главная — N-1.\n\n    [ d[1]  du[1]                         ]\n    [ dl[1] d[2]  du[2]                   ]\n    [ 0     dl[2] d[3] du[3]              ]\n    [           ...  ...  ...             ]\n    [                ...  ...     du[N-2] ]\n    [                     dl[N-2] d[N-1]  ]\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y","text":"\"     DRP(y::Int, m::Int,         Xₙ::Vector, N::Int,         ε::Real,         ulₘ::Vector, urₘ::Vector,         qₙ::Vector) -> (::Vector, ::Vector, ::Vector)\n\nВозращает три диагонали якоибана правой части прямой задачи, чтобы после сформировать трехдигональную матрицу Tridiagonal.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\nReturn\n\nВозвращает три вектора dl, d, dl элементов якоибана. Нижняя и верхняя диагонали длины N-2, главная — N-1.\n\n    [ d[1]  du[1]                         ]\n    [ dl[1] d[2]  du[2]                   ]\n    [ 0     dl[2] d[3] du[3]              ]\n    [           ...  ...  ...             ]\n    [                ...  ...     du[N-2] ]\n    [                     dl[N-2] d[N-1]  ]\n\nExample\n\njulia> # Данные необохдимо подготовить, например, как в examples/example_direct.jl\n\njulia> # Подготовим массивы, выбросив граничные точки\n\njulia> # ведь тестируемая функция — для внутреннего использования\n\njulia> qq = qₙ[2:N];\n\njulia> y = y₀[2:N];\n\njulia> dl, d, du = NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y(y, 1, Xₙ, N, ε, ulₘ, urₘ, qq);\n\njulia> Tridiagonal( dl, d, du )\n49×49 Tridiagonal{Float64,Array{Float64,1}}:\n -991.038   305.462      ⋅         ⋅         ⋅         ⋅         ⋅     …       ⋅         ⋅         ⋅         ⋅         ⋅        ⋅\n[...]\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP","text":"adjointRP(y::Vector, m::Int,\n          Xₙ::Vector, N::Int,\n          Tₘ::Vector, M::Int,\n          ε::Real,\n          ulₘ::Vector, urₘ::Vector,\n          qₙ::Vector,\n          Uₙₘ::Matrix, f1::Vector, f2::Vector)\n\nВычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nArguments\n\ny::Vector:          Вектор размера N-1, решение в текущий момент без ГТ.\nm::Int:             Номер шага в сетке по времени.\nXₙ::Vector:         Вектор размера N+1 сетки по X, вместе с ГТ.\nN::Int:             Число интервалов в полной сетке по X.\nTₘ::Vector:         Вектор размера M+1 сетки по T.\nM::Int:             Число интервалов в полной сетке по T.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Vector:        Вектор сеточных значений левого ГУ.\nurₘ::Vector:        Вектор сеточных значений правого ГУ.\nqₙ::Vector:         Вектор размера N-1 сеточные значений  неоднородности без ГТ.\nUₙₘ::Matrix:        Матрица размера N-1, M+1 решения прямой задачи при данном qₙ.\nf1::Vector:         Эспериментальные данные — положение внутреннего слоя, размера M+1.\nf2::Vector:         Эспериментальные данные — значение функции на внутреннеем слое, размера M+1.\nw::Real:            Априорный параметр в аппроксимации дельта-функции (см. heterogeneity, δw).\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.deltaw-Tuple{Int64,Real,Array{T,1} where T,Int64,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.deltaw","text":"deltaw(n::Int, x₀::Real, Xₙ::Vector, N::Int, w::Real)\n\nВычисляет delta(x - x₀), где x = Xₙ[n]. n — номер узла в сетке Xₙ(без граничных точек).\n\nИспользует более точную конечно разностную аппроксимацию дельта функции, w — априорный параметр, см. δw.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.directRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.directRP","text":"directRP(y::Vector, m::Int,\n         Xₙ::Vector, N::Int,\n         ε::Real,\n         ulₘ::Vector, urₘ::Vector,\n         qₙ::Vector)\n\nВычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nArguments\n\ny::Vector:          Вектор размера N-1, решение в текущий момент без ГТ.\nm::Int:             Номер шага в сетке по времени.\nXₙ::Vector:         Вектор размера N+1 сетки по X, вместе с ГТ.\nN::Int:             Число интервалов в полной сетке по X.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Vector:        Вектор сеточных значений левого ГУ.\nurₘ::Vector:        Вектор сеточных значений правого ГУ.\nqₙ::Vector:         Вектор размера N-1 сеточные значений  неоднородности без ГТ.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.dparams-Tuple{}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.dparams","text":"dparams()\n\nВозвращает стандартный набор параметров для равномерной сетки.\n\nReturn\n\n`a, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀ `\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform-Tuple{}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform","text":"dparams_nonuniform()\n\nВозвращает стандартный набор параметров для неравномерной сетки.\n\nReturn\n\nreturn a, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀, meshf;\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros-Tuple{Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros","text":"find_f_zeros(f::Vector, Xₙ::Vector)\n\nНаходит такой x, что f(x) = 0. f — сеточные значения функции на сетке Xₙ.\n\nwarning: Warning\nФункция обязана пересекать ноль. Не сработает на неотрицательных функциях.\nВозвращает только аргуент реализующий первый ноль.\nРешение ищется аппроксимацией.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data-Tuple{Array{T,2} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data","text":"generate_obs_data(u::Matrix, Xₙ::Vector, N::Int,\n                  Tₘ::Vector, M::Int,\n                  qₙ::Vector,\n                  ulₘ::Vector, urₘ::Vector)\n\nФнукция-сокращение.\n\n#Return ϕl, ϕr, ϕ, f1_data, f2_data\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.heterogeneity-Tuple{Int64,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.heterogeneity","text":"heterogeneity(n::Int, m::Int,\n             Xₙ::Vector, N::Int,\n             Tₘ::Vector, M::Int,\n             Uₙₘ::Matrix,\n             f1::Vector, f2::Vector,\n             w::Real)\n\nНеоднородность выражающая невязку текущего решения с искомым. 2 delta( x - f_1(t) ) ( u^s(xt) - f_2(t) ).\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.shishkin_mesh","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.shishkin_mesh","text":"shishkin_mesh(a::Real, b::Real,\n              x_tp::Real, ε::Real,\n              N::Int = 50,\n              C_i::Real = 1.0, K_i::Real = 1.0,\n              C_b::Real = 1.0, K_b::Real = 1.0)\n\nВозвращает кусочнораномерную сетку со сгущением на границах и на переходном слое.\n\nArguments\n\na::Int      Левая граница.\nb::Int      Правая граница.\nx_tp::Real  Положение переходного слоя.\nε::Real     Малый параметр при старшей производной.\nC_i::Real   Масштабирующий коэффициент для ширины внутреннего сгущения.\nK_i::int    Масштабирующий коэффициент количества интервалов внутреннего сгущения.\nC_b::Real   Масштабирующий коэффициент для ширин пограничных сгущений.\nK_b::Int    Масштабирующий коэффициент количеств интервалов пограничных сгущений.\nK::Int      Кол-во интервалов вне всех сгущений.\n\nReturn\n\nКусчноравномерную сетк, на эскизе чтоками изображены узлы сетки.\n\n.....  .  .  .  .  .  .  .  .  .  .......  .  .  .  .  .  .  .  .  .  .  ......\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints-Tuple{Array{T,1} where T,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints","text":"strip_borderPoints(a::Vector, N) -> Vector\n\nФункция для внутренного использования.\n\nВходящий массив должен быть размера N+1. Обрезает граничные точки слева и справа. Возвращает массив размера N-1.\n\nExample\n\njulia> N = 10; a = collect(1:N+1);\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints(a, N)\n9-element Array{Int64,1}:\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.δw-Tuple{Real,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.δw","text":"δw(x::Real, ω::Real) -> Real\n\nЛинейная аппроксимация δ(x), ω — эвристический парамет. Подбирается так, чтобы невязка сопряженной задачи 2 delta( x - f_1(t)) ( u(xt) - f_2(t)) при подстановке в неё u(x,t;q) истинного q обнулялась почти везде, но не всюду.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂ARP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂ARP_∂y","text":"∂ARP_∂y(y::Vector, m::Int,\n      Xₙ::Vector, N::Int,\n      Tₘ::Vector, M::Int,\n      ε::Real,\n      ulₘ::Vector, urₘ::Vector,\n      qₙ::Vector,\n      Uₙₘ::Matrix, f1::Vector, f2::Vector) -> Tridiagonal\n\nОбертка фнукции ARP_y, которая возвращает Tridiagonal( ARP_y(...)) трехдиагональную матрицы из векторов, которые возвращает ARP_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y","text":"∂DRP_∂y(y::Vector, m::Int,\n        Xₙ::Vector, N::Int,\n        ε::Real,\n        ulₘ::Vector, urₘ::Vector,\n        qₙ::Vector) -> Tridiagonal\n\nОбертка фнукции DRP_y, которая возвращает Tridiagonal( DRP_y(...)) трехдиагональную матрицу из векторов, которые возвращает DRP_y(...).\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y","text":"∂adjointRP_∂y(y::Vector, m::Int,\n               Xₙ::Vector, N::Int,\n               Tₘ::Vector, M::Int,\n               ε::Real,\n               ulₘ::Vector, urₘ::Vector,\n               qₙ::Vector,\n               Uₙₘ::Matrix, f1::Vector, f2::Vector,\n               w::Real)\n\nФункция якобиана для adjointRP. Все аргументы, размерности входных векторов такие же, как и у adjointRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y","text":"∂directRP_∂y(y::Vector, m::Int,\n              Xₙ::Vector, N::Int,\n              ε::Real,\n              ulₘ::Vector, urₘ::Vector,\n              qₙ::Vector)\n\nФункция якобиана для adjointRP. Размерности входных векторов такие же, как и у directRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"adjoint/adjoint/#Сопряженная-задача-1","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"section"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача формулируется следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 psipartial x^2 + fracpartial psipartial t = u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Перепишем её в удобном виде для применений метода жесткий прямых","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 +  u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Дальше будем использовать уже введенную в решении прямой задачи сетку, x_n in X_N, psi_n equiv psi_n(t) equiv psi(x_n t), u_n equiv u_n(t) equiv u(x_n t), q_n equiv q(x_n).","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_npartial t = - varepsilon frac psi_n+1 - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline1 N-1 quad t in (0T \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T \n    psi_n(T) = 0 quad n = overline 0 N\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сведем дифференциально-алгебраическую систему к дифференциальной, путем подстановки нулевых граничных условий.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_1     partial t = - varepsilon frac psi_2     - 2 psi_1              h^2 +  u_1 fracpsi_2 2h + q_1psi_1  -\n     qquad  - 2delta(x_1 - f_1(t))(u_1(t) - f_2(t))  quad t in (0T \n    fracpartial psi_n     partial t = - varepsilon frac psi_n+1   - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2 quad t in (0T \n    fracpartial psi_N-1 partial t = - varepsilon frac          -2 psi_N-1 + psi_N-2  h^2 +  u_N-1 frac - psi_N-22h + q_N-1psi_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t))  quad t in (0T \n    psi_n(T) = 0 quad n = overline0 N\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Введем следующие обозначения:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Описание Обозначение\nвектор столбец искомой функции размерностью N-1: mathbfy = (psi_1 psi_2 dots psi_N-1)^T.\nвектор столбец начальных значений размерностью N-1: mathbfy_0 = (0 0 dots 0)^T.\nвектор столбец правой части размерность N-1: mathbff(mathbfy t) для вышеприведенной системы.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nЗамечание, о технической реализации в коде adjointRP.u, Xₙ передаются как есть, вместе с граничными точками! Внутри функции они локально модифицируются, для сохранения индексации.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1 = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1 fracy_2 2h + q_1y_1  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t))\n    ARP_n = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2\n    ARP_N-1 = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1 frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t)) \nendaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"warning: Warning\nСетку нужно развернуть, в тексте об этом дописать.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Используя уже введенную временную сетку по времени t_m in T_m, ARP_n^m equiv ARP_n(t_m) equiv ARP(x_n t_m).","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1^m = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1^m fracy_2 2h + q_ny_1  -\n     qquad  - 2delta(x_1 - f_1^m)(u_1^m - f_2^m)\n    ARP_n^m = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n^m fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1^m)(u_n^m - f_2^m) quad n = overline2 N-2\n    ARP_N-1^m = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1^m frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1^m)(u_N-1^m - f_2^m) \nendaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Теперь, систему ОДУ можно записать следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbfARP  (mathbftextbfyt) quad t in t_0T)\n        mathbftextbfy(T) = mathbftextbfy_init\n    endaligned\n    right","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nПравая часть в уравнении для mathbfW в явном виде не зависит от t, а все сеточные функции u, f_1, f_2 берутся в момент времени t_m, вместо frac t_m+1 + t_m2.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Найдем решение сопряженной задачи следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfW \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbfARP_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfW = \n        qquadqquadqquadqquadquad = mathbftextbfARP  Big(mathbftextbfy(t_m) t_mBig)\n    endaligned","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"DocTestSetup = quote\n    using NonLinearReactionAdvectionDiffusionWithFrontData\n    using Plots\nend\n","category":"page"},{"location":"#Главная-1","page":"Главная","title":"Главная","text":"","category":"section"},{"location":"#Постановка-обратной-задачи-1","page":"Главная","title":"Постановка обратной задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Рассмотрим прямую задачу для сингулярно возмущенного уравнения типа Бюргерса:","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Решение этой задачи имеет движущийся слой, положение которого во времени описывает x = x_tp(t).","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Обратная задача состоит в определении коэффициента линейного усиления q(x), x in 01, по известной дополнительной информации о положении переходного слоя и значения функции на переходном слое:","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"x_tp = f_1(t) qquad u(x_tp(t)t) = f_2(t) qquad t in 0 T","category":"page"},{"location":"#Содержание-1","page":"Главная","title":"Содержание","text":"","category":"section"},{"location":"#Прямая-задача-1","page":"Главная","title":"Прямая задача","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Pages = [\n    \"direct/direct.md\",\n    \"direct/experimental_data.md\",\n    \"generated/docexample_direct.md\",\n    \"direct/direct_check.md\",\n]\nDepth = 1","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/examples/dt_direct.jl\"","category":"page"},{"location":"generated/doctest_direct/#Непосредственная-реализация-проверки-1","page":"-","title":"Непосредственная реализация проверки","text":"","category":"section"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\nnothing #hide","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Тест проверяет корректность решения прямой задачи. Алгоритм описан в /docs/src/direct/direct_check.md Возвращает решение, аналитическое решение, сетку по X, сетку по T.","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"using NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing ForwardDiff;\nnothing #hide","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Зададим параметры для прямой задачи","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"u_l(t) = 0;                     # ГУ удовлетворяющие модельной функции\nu_r(t) = 0;                     # ГУ удовлетворяющие модельной функции\nqf(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 1;                   # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ= u_l.(Tₘ);                  # Сеточные значения левого  ГУ\nurₘ= u_r.(Tₘ);                  # Сеточные значения правого ГУ\nnothing #hide","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Зададим модельную функцию и невязку, получаемую после подстановки g в исходное уравнение","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"function g(x, m)\n    t = Tₘ[m]\n    (1 - 2t)*sin(π*x)\nend\nfunction g_d(x::Real, m::Int)\n    t = Tₘ[m];\n    - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - qf(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x)\nend\n\ny₀ = g.(Xₙ, 1);               # Начальные условия\nnothing #hide","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Модельное решение найденное с помощью известного аналитического решения","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"u_model = [ g(x, m) for x in Xₙ, m in 1:M+1];\nnothing #hide","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"function RP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ)\n    d = [ g_d(x, m) for x in Xₙ[2:N] ]\n    NonLinearReactionAdvectionDiffusionWithFrontData.directRP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) - d\nend","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Хоть мы и конструируем якобиан с помощью автоматического дифференцирования, примите во внимание, что Якобиан f_y при добавлении g_d останется без изменений, т.к. g_d зависит только от xt. То, что он не зависит от добавления g_d можно убедиться изменением порядка этих двух строк, ну а так же на бумаге.","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"j(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) = ForwardDiff.jacobian( z -> RP(z, m, Xₙ, N, ε, ulₘ, urₘ, qₙ), y)","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"С использованием автоматического дифференцирования","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, j);\n@test all(isapprox.(u_model, u, atol = 0.01))","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"С использованием трехдиагонального якобиана","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n(u, u_model, Xₙ, Tₘ)","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(u, Xₙ, Tₘ, dd, dd, dd, d, d, u_model; name = \"dicrect_check.gif\")","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"err = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/doctest_direct/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"}]
}
