var documenterSearchIndex = {"docs":
[{"location":"direct/direct_check/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка на модельном решении","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Подставим найденные производные в исходное уравнение (см.Постановка задачи), таким образом определив g_d (от англ. discrepancy).","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u - g_d(xt) quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Найдем решение следующим образом:","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1 \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n        qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big) + g_d(mathbfX_nfract_m + 1 + t_m2)\n    endaligned","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"где g_d(mathbfX_n) — значения g_d на сетке x_1 x_x ldots x_N, т.е. на сетке mathbfX_n без граничных точек. Решение будем находить с помощью функции solve, но перед этим сконструируем функцию правой части и её якобиан и передадим их в качестве аргументов.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/direct_with_model.jl\". Файл содержит один @testset, внутри него реализовано решение вышеописанной системы, проверка его корректности через @test. А так же, @testset возвращает u, u_model, Xₙ, Tₘ, что соответствует решению, аналитическому решению, сетке по X, T.","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"using NonLinearReactionAdvectionDiffusionWithFrontData, Test, ForwardDiff\nu, u_model, Xₙ, Tₘ = include(\"../../../test/direct_check.jl\")\nnothing #hide","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"d = [missing, missing];\nmake_gif(u, Xₙ, Tₘ, d, d, d, d, u_model; convert2mp4=true)","category":"page"},{"location":"direct/direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"using LaTeXStrings, Plots\nerr = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"direct/direct/#Решение-прямой-задачи-1","page":"Прямая задача","title":"Решение прямой задачи","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Если записать систему в следующем виде:","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbff  (mathbftextbfyt) quad t in (t_0T\n        mathbftextbfy(t_0) = mathbftextbfy_init\n    endaligned\n    right","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"где","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    beginaligned\n        mathbftextbfy = big(u_1  u_2   ldots  u_N - 1 big)^T \n        mathbftextbff = big(f_1  f_2  ldots  f_N - 1big)^T \n        mathbftextbfy_init = big(u_init (x_1)  u_init (x_2)  ldots  u_init (x_N - 1) big)^T\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"u_init(x_n) вычисляется с помощью u_init(x).","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"То текущая функция определяет вектор-функцию mathbftextbff следующим образом:","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    beginaligned\n        f_1 =       varepsilon dfracy_2        - 2y_1       + u_left(t)h^2 + y_1       dfracy_2        - u_left(t)2h - q(x_1) y_1 \n        f_n =       varepsilon dfracy_n + 1    - 2y_n       + y_n - 1h^2   + y_n       dfracy_n + 1    - y_n - 12h   - q(x_n) u_n quad n=overline2 N-2 \n        f_N - 1 = varepsilon dfracu_right(t) - 2y_N - 1 + y_N - 2h^2   + y_N - 1 dfracu_right(t) - y_N - 22h   - q(x_N-1) y_N-1\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"На каждом временном шаге, решение находится как:","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"где W_1 находится из","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"beginaligned\n    leftmathbftextbfE - alpha  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n    qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big)\nendaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"mathbff_mathbfy(mathbfy(t_m) t_m) — якобиан функции directRP(...) по вектору y (в момент времени t_m) в момент времени t_m. Эта матрица Якоби имеет следущие ненулевые элементы.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"beginaligned\n     left(f_yright)_11   equiv  fracpartial f_1partial y_1  =  varepsilondfrac-2h^2 - dfracy_2 - u_left(t)2h + q(x_1) \n\n      left(f_yright)_nn - 1   equiv  fracpartial f_npartial y_n - 1  =  varepsilon dfrac1h^2 + dfracy_n2h quad n=overline2 N-1\n\n      left(f_yright)_nn   equiv  fracpartial f_npartial y_n  =   -varepsilon dfrac2h^2 - dfracy_n+1 - y_n-12h + q(x_n) quad n=overline2 N-2\n\n      left(f_yright)_nn + 1   equiv  fracpartial f_npartial y_n + 1  =  varepsilon dfrac1h^2 - dfracy_n2h quad n=overline1 N-2\n\n      left(f_yright)_N - 1N - 1   equiv  fracpartial f_N - 1partial y_N - 1  =   varepsilon dfrac-2h^2 - dfracu_right(t) - y_N - 22h + q(x_N)\nendaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"(Image: )","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Левое вырожденное решение","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^ldx = q(x) quad x in (0 1 \n     phi^l(0) = u_l\nendaligned\nright","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Правое вырожденное решение","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^rdx = q(x) quad x in 0 1) \n     phi^r(1) = u_r\nendaligned\nright","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Пересечение функции Phi(x) = abs(phi^l - phi^r)2 + phi^l с функцией u(x t) и будет определять положение переходного слоя x_tp = f1(t) и значение функции u(x_tp(t)t) = f2(t) в этой точке.","category":"page"},{"location":"direct/apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Для поиска положения переходного слоя x_tp в момент времени t0 найдем x при котором Phi(x) - u(x t0) = 0.","category":"page"},{"location":"generated/example_adjoint/#Решение-прямой-задачи-1","page":"Пример","title":"Решение прямой задачи","text":"","category":"section"},{"location":"generated/example_adjoint/#","page":"Пример","title":"Пример","text":"Сопряженная задача определяется для сеточного решения некоторой прямой задачи, и некоторых априорных данных.","category":"page"},{"location":"generated/example_adjoint/#","page":"Пример","title":"Пример","text":"using NonLinearReactionAdvectionDiffusionWithFrontData","category":"page"},{"location":"generated/example_adjoint/#","page":"Пример","title":"Пример","text":"Сначала, сгенирируем априорные данные, на увеличенном количестве узлов.","category":"page"},{"location":"generated/example_adjoint/#","page":"Пример","title":"Пример","text":"u_l(t) = -8 #+ cos(2*π * t);\nu_r(t) =  4 #+ (1 + sin(2*π * t));\nq(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.28;                # Область по T\nN, M = 250, 400;                # Увеличенное Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      q.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₙ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₙ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\ny₀ = u_init.(Xₙ);               # Начальные условия\nnothing #hide\n\nu = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₙ, urₙ, qₙ);\n\n# Вырожденные корни\n# TODO: FIX PHIDETERMINATION\ny = u[:,1]\nϕl = phidetermination(qₙ, y, ulₙ, Xₙ, N::Int);\n# Разворачиваем сетку по Х, а после — решение\nϕr = phidetermination(qₙ, y, urₙ, Xₙ[end:-1:1], N::Int);\nϕr = ϕr[end:-1:1];\n# Полуразность вырожденных корней\nϕ = NonLinearReactionAdvectionDiffusionWithFrontData.Φ(ϕl, ϕr, N);\n# Положение переходного слоя\nf1 = NonLinearReactionAdvectionDiffusionWithFrontData.f1(ϕ, u, Xₙ, N, M);\n# Значение функции на переходном слое\nf2 = NonLinearReactionAdvectionDiffusionWithFrontData.f2(f1, u, Xₙ, N, M);","category":"page"},{"location":"generated/example_adjoint/#Решение-сопряженной-задачи-1","page":"Пример","title":"Решение сопряженной задачи","text":"","category":"section"},{"location":"generated/example_adjoint/#","page":"Пример","title":"Пример","text":"Uₙₘ = u; # Сохраним старую матрицу\ny₀ = [0.0 for i in 1:N+1];\nψl = [0.0 for i in 1:M+1];\nψr = [0.0 for i in 1:M+1];\n\n# tmp vars\n# X = Xₙ[2:N];\n# q_ = qₙ[2:N];\n# y = y₀[2:N];\n# T = Tₘ[end:-1:1];\n# U = Uₙₘ[2:N, :];\n# NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP(y, 1, X, N, T, M, ε, ψl, ψr, q_, U, f1, f2)\n# NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y(y, 1, X, N, T, M, ε, ψl, ψr, q_, U, f1, f2)\n\nψ = solve_adjoint(y₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1, f2)\n\n# На отрисовку, решение сопряженной задачи передадим в инвертированном времени.\nmake_gif(ψ[:,end:-1:1], Xₙ, Tₘ[end:-1:1]; frame_skip = div(M, 350), frames_to_write=81, name=\"adjoint.gif\", convert2mp4 = true)\n\n![](adjoint.mp4)","category":"page"},{"location":"adjoint/adjoint_check/#Проверка-решения-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Проверка решения сопряженной задачи","text":"","category":"section"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Подставим найденные производные в исходное уравнение (см.Сопряженная задача) и перенеся все в правую часть, определим g_d.","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"g_d(xt) = 2 sin(pi x) - ( - varepsilon pi^2 (1 - 2t) sin(pi x) )+\nu(xt) pi (1 - 2t) cos(pi x) + q(x) (1 - 2t) sin(pi x) - 2 delta( x - f_1(t) ) (u(xt) - f_2(t))","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"adjoint/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"left\nbeginaligned\n     fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 + u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) - g_d quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"functional/functional/#Вычисление-функционала-1","page":"Функционал","title":"Вычисление функционала","text":"","category":"section"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"Jq = intlimits^T_0 left( u(f_1(t) t q) - f_2(t) right)^2 dt + alpha intlimits_0^1 left( q(x) right)^2 dx","category":"page"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"где f_1 f_2 — априорная информация, которая была единожды вычислена до итерационного процесса, при известном q(x), alpha — параметр регуляризации, пока равный нулю.","category":"page"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"После вычисления сеточных значения u(xt q^s) на сетках Xₙ Tₘ нам необходимо найти значение искомой функции на переходном слое u( f_1(t) t q).","category":"page"},{"location":"functional/functional/#Вычисление-градиента-функционала-1","page":"Функционал","title":"Вычисление градиента функционала","text":"","category":"section"},{"location":"functional/functional/#","page":"Функционал","title":"Функционал","text":"Jq^s(x) = intlimits_0^T u^(s) (xt) psi^(s)(xt) dt","category":"page"},{"location":"reference/#Справочник-1","page":"Справочник","title":"Справочник","text":"","category":"section"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]","category":"page"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","text":"module NonLinearReactionAdvectionDiffusionWithFrontData\n\nПакет реализует исследование в рамках гранта РФФИ #20-31-70016 \"Численные методы решения обратных задач для нелинейных сингулярно возмущённых уравнений типа реакция-диффузия-адвекция с данными о положении фронта реакции\".\n\nАвтор исходного кода пакета:\n\nАндрей Борзунов, Кафедра математики физического факультета МГУ им. Ломоносова.\n\nИсполнители гранта:\n\nМельникова Алина Александровна\nЛевашова Наталия Тимуровна\nЛукьяненко Дмитрий Витальевич (Руководитель)\nБыцюра Светлана Владимировна\nБорзунов Андрей Анатольевич\nИсаев Темур Фуркатович\nАргун Рауль Ларикович\nГорбачев Александр Викторович\n\nДокументация: https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl\n\n\n\n\n\n","category":"module"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J","text":"J(uˢ::Matrix, Xₙ::Vector, N::Int,\n       Tₘ::Vector, M::Int,\n       f1::Vector, f2::Vector,\n       qₙˢ::Vector, α::Real = 0.0) -> Real\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J_q-Tuple{Array{T,2} where T,Array{T,2} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J_q","text":"J_q(uˢ::Matrix, ψˢ::Matrix,\n         Xₙ::Vector, N::Int,\n         Tₘ::Vector, M::Int) -> Vector\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP","text":"function adjointRP(y, m::Int, t, Xₙ, N, Tₘ, M, ε, qₙ, u, f1, f2)\n\nnote: Note\nu, Xₙ передаются как есть, вместе с граничными точками, внутри функции они локально модифицируются, для сохранения индексации\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.delta","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.delta","text":"delta(x, Xₙ, x₀ = 0) -> ::Real\n\nВычисляет конечно разностную аппроксимацию дельта функции delta(x x₀) на сетке Xₙ исходя из intlimits_a^b delta(x x₀) dx = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","text":"make_gif(u::Matrix, Xₙ::Vector, Tₘ::Vector,\n              ϕ_l::Vector = missings(2), ϕ_r::Vector = missings(2),\n              f1::Vector = missings(2), f2::Vector = missings(2),\n              analitical = nothing;\n              frames_to_write::Int = -1, frame_skip::Int=-1,\n              name = \"solution.gif\", convert2mp4 = false)\n\nРисует gif анимацию решения каждый frame_skip кадр, вплоть по frames_to_write-ый кадр, сохраняет как \"results/name\".\n\nТак же рисует аналитическое решение analitic(x,t), если таково передано.\n\ntip: Tip\nPass an empty string to avoid saving at disk.\n\nTODO: Fix doc\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","text":"make_plot(u::Matrix, Xₙ::Vector, Tₘ::Vector, m::Int,\n               ϕ_l::Vector = missings(2), ϕ_r::Vector = missings(2),\n               f1::Vector = missings(2), f2::Vector = missings(2),\n               analitical = nothing)\n\nРисует m-ый кадр решения u. Xₙ, Tₘ — сетки. ϕ_l, ϕ_r — вырожденные решения. f1, f2 — сгенерированные априорные данные. analitical — или функция или сеточные значения аналитического решения.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination","text":"phidetermination(q, u, u_border, Xₙ, N::Int)\n\nРешает ОДУ для нахождения вырожденных корней.\n\ndanger: Danger\nФункция некорректно обрабатыет непостоянные ГУ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve","text":"solve(y₀::Vector, Xₙ::Vector, N::Int,\n           Tₘ::Vector, M::Int,\n           ε::Real, ulₘ::Vector, urₘ::Vector,\n           qₙ::Vector,\n           RP::Function = directRP,\n           jac::Function = ∂directRP_∂y;\n           α::Complex = complex(0.5, 0.5)) -> Matrix —\n\nФункция, которая находит решение с помощью одностадийной схемы Розенброка с комплексным коэффициентом.\n\nArguments\n\ny₀::Vector:         Сеточные значения начального условия.\nXₙ::Vector:         Пространственная сетка по X.\nN::Int:             Число узлов сетки по X.\nTₘ::Vector:         Пространственная сетка по t.\nM::Int:             Число узлов сетки по t.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Function:      Сеточные значения левого ГУ.\nurₘ::Function:      Сеточные значения правого ГУ.\nqₙ::Vector:         Сеточные значения \"неоднородности\", см. постановку задачи.\nRP::Function:       Функция вычисления вектора правой части.\njac::Function:      Якобиан правой части по вектору y — f_y.\nα::Complex:         Коэффициент схемы. При α = 0 — схема Эйлера, при α = complex(0.5, 0.5) — схема Розенброка с комплексным коэффициентом.\n\nReturn\n\nМатрицу размера (N+1 M+1), содержащую значения искомой функции на сетках X_n T_m,.\n\ninfo: Info\nXₙ, qₙ, y₀     векторы размера N+1!\nTₘ, ulₘ, urₘ   векторы размера M+1!\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","text":"warning: Warning\nМассивы Xₙ, Tₘ, u, f1, f2 Передаются как есть! Они переварачиваются внутри функции локально.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.u_init-Tuple{Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.u_init","text":"u_init(x::Real; ε = 0.2) -> Real\n\nНачальные условия в виде (x^2 - x -2) -6 tanh( -3 xi), где xi = fracx - 025ε.\n\nnote: Note\nГраничные условия для этих начальных условий должны быть заданы как (-8, 4).\n\nnote: Note\nВы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.\n\nExample\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)\n11-element Array{Float64,1}:\n -7.993366656356917\n -7.958156688432881\n -5.970893714323723\n  1.600893714323723\n  3.628156688432881\n  3.7433666563569172\n  3.759669571706625\n  3.7899835485135176\n  3.8399991809276504\n  3.9099999592207864\n  3.9999999979697227\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.Φ-Tuple{Array{T,1} where T,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.Φ","text":"Φ(ϕ_l::Vector, ϕ_r::Vector, N::Int) -> ::Vector\n\nВычисляет значение функции на переходном слое phi_l - phi_r2 с помощью левого phi_l и правого phi_r вырожденного корня.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.directRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.directRP","text":"directRP(y::Vector, m::Int,\n         Xₙ::Vector, N::Int,\n         ε::Real,\n         ulₘ::Vector, urₘ::Vector,\n         qₙ::Vector)\n\nВычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nArguments\n\ny::Vector:          Вектор размера N-1, решение в текущий момент без ГТ.\nm::Int:             Номер шага в сетке по времени.\nXₙ::Vector:         Вектор размера N-1 сетки по X, без ГТ.\nN::Int:             Число узлов в полной сетке по X.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Vector:        Вектор сеточных значений левого ГУ.\nurₘ::Vector:        Вектор сеточных значений правого ГУ.\nqₙ::Vector:         Сеточные значения неоднородности без ГТ.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.Xₙ, qₙ, y размера N-1!\n\nnote: Note\nФункция работает по формулам для равномерной сетки!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f1-Tuple{Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f1","text":"f1(ϕ::Vector, u::Matrix, Xₙ::Vector, N::Int, M::Int)\n\nНаходит значение искомой функции на переходном слое f_1(t) = u(x_tp t) путем поиска точки пересечения u(xt) и ϕ(x).\n\nТочка пересечения находится путем интерполяции функции u(xt) - ϕ(x) = 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints-Tuple{Array{T,1} where T,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints","text":"strip_borderPoints(a::Vector, N) -> Vector\n\nФункция для внутренного использования.\n\nВходящий массив должен быть размера N+1. Обрезает граничные точки слева и справа. Возвращает массив размера N-1.\n\nExample\n\njulia> N = 10; a = collect(1:N+1);\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints(a, N)\n9-element Array{Int64,1}:\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y","text":"∂adjointRP_∂y(y::Vector, m::Int,\n              Xₙ::Vector, N::Int,\n              ε::Real,\n              ulₘ::Vector, urₘ::Vector,\n              qₙ::Vector)\n\nФункция якобиана для adjointRP. Размерности входных векторов такие же, как и у adjointRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.Xₙ, qₙ, y размера N-1!\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y","text":"∂directRP_∂y(y::Vector, m::Int,\n              Xₙ::Vector, N::Int,\n              ε::Real,\n              ulₘ::Vector, urₘ::Vector,\n              qₙ::Vector)\n\nФункция якобиана для adjointRP. Размерности входных векторов такие же, как и у directRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.Xₙ, qₙ, y размера N-1!\n\n\n\n\n\n","category":"method"},{"location":"adjoint/adjoint/#Сопряженная-задача-1","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"section"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача формулируется следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 psipartial x^2 + fracpartial psipartial t = u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Перепишем её в удобном виде для применений метода жесткий прямых","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 +  u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Дальше будем использовать уже введенную в решении прямой задачи сетку, x_n in X_n, psi_n equiv psi_n(t) equiv psi(x_n t), u_n equiv u_n(t) equiv u(x_n t), q_n equiv q(x_n). Произведем аппроксимацию частных производных fracpartial partial x, fracpartial^2 partial x^2 по x с помощью конечных разностей.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_npartial t = - varepsilon frac psi_n+1 - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline1 N-1 quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi_n(T) = 0 quad x in 0 1\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сведем дифференциально-алгебраическую систему к дифференциальной, путем подстановки нулевых граничных условий.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_1     partial t = - varepsilon frac psi_2     - 2 psi_1              h^2 +  u_1 fracpsi_2 2h + q_npsi_1  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t))  quad t in (0T) \n    fracpartial psi_n     partial t = - varepsilon frac psi_n+1   - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2 quad t in (0T) \n    fracpartial psi_N-1 partial t = - varepsilon frac          -2 psi_N-1 + psi_N-2  h^2 +  u_N-1 frac - psi_N-22h + q_N-1psi_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t))  quad t in (0T) \n    psi_n(T) = 0 quad n = overline0 N\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Введем","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"вектор столбец искомой функции размерностью N-1: mathbfy = (psi_1 psi_2 dots psi_N-1)^T.\nвектор столбец начальных значений размерностью N-1: mathbfy_i = (0 0 dots 0)^T.\nвектор столбец mathbfARP(mathbfy t) который будет представлять правую часть вышеприведенной системы.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nЗамечание, о технической реализации в коде adjointRP.u, Xₙ передаются как есть, вместе с граничными точками! Внутри функции они локально модифицируются, для сохранения индексации.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1 = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1 fracy_2 2h + q_1y_1  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t))\n    ARP_n = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2\n    ARP_N-1 = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1 frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t)) \nendaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"warning: Warning\nСетку нужно развернуть, в тексте об этом дописать.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Используя уже введенную временную сетку по времени t_m in T_m, ARP_n^m equiv ARP_n(t_m) equiv ARP(x_n t_m).","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1^m = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1^m fracy_2 2h + q_ny_1  -\n     qquad  - 2delta(x_1 - f_1^m)(u_1^m - f_2^m)\n    ARP_n^m = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n^m fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1^m)(u_n^m - f_2^m) quad n = overline2 N-2\n    ARP_N-1^m = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1^m frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1^m)(u_N-1^m - f_2^m) \nendaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Теперь, систему ОДУ можно записать следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbfARP  (mathbftextbfyt) quad t in t_0T)\n        mathbftextbfy(T) = mathbftextbfy_init\n    endaligned\n    right","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nПравая часть в уравнении для mathbfW в явном виде не зависит от t, а все сеточные функции u, f_1, f_2 берутся в момент времени t_m, вместо frac t_m+1 + t_m2.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Найдем решение сопряженной задачи следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfW \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbfARP_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfW = \n        qquadqquadqquadqquadquad = mathbftextbfARP  Big(mathbftextbfy(t_m) t_mBig)\n    endaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"(Image: )","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"DocTestSetup = quote\n    using NonLinearReactionAdvectionDiffusionWithFrontData\n    using Plots\nend\n","category":"page"},{"location":"#Главная-1","page":"Главная","title":"Главная","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"","category":"page"},{"location":"#Постановка-задачи-1","page":"Главная","title":"Постановка задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"generated/example_direct/#Решение-прямой-задачи-1","page":"Пример","title":"Решение прямой задачи","text":"","category":"section"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\n\nu_l(t) = -8 #+ cos(2*π * t);\nu_r(t) =  4 #+ (1 + sin(2*π * t));\nq(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.28;                # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      q.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\ny₀ = u_init.(Xₙ);               # Начальные условия\nnothing #hide","category":"page"},{"location":"generated/example_direct/#Нахождение-решения-1","page":"Пример","title":"Нахождение решения","text":"","category":"section"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"Все массивы передаются внутрь функции solve полностью, вместе с граничными точками. Внутри, они локально модифицируются, и на вход directRP, ∂directRP_∂y подаются без крайних точек.","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"u = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"Запись gif только решения","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"make_gif(u, Xₙ, Tₘ; frame_skip = div(M,50), frames_to_write=M, name=\"example_direct.gif\")\nnothing #hide","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"(Image: solution gif)","category":"page"},{"location":"generated/example_direct/#Генерация-априорной-информации-1","page":"Пример","title":"Генерация априорной информации","text":"","category":"section"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"# Вырожденные корни\n# TODO: FIX phidetermination\ny = u[:,1] # TMP FIXURE\nϕl = phidetermination(qₙ, y, ulₘ, Xₙ, N::Int);\n# Разворачиваем сетку по Х, а после — решение\nϕr = phidetermination(qₙ, y, urₘ, Xₙ[end:-1:1], N::Int);\nϕr = ϕr[end:-1:1];\n# Полуразность вырожденных корней\nϕ = NonLinearReactionAdvectionDiffusionWithFrontData.Φ(ϕl, ϕr, N);\n# Положение переходного слоя\nf1 = NonLinearReactionAdvectionDiffusionWithFrontData.f1(ϕ, u, Xₙ, N, M);\n# Значение функции на переходном слое\nf2 = NonLinearReactionAdvectionDiffusionWithFrontData.f2(f1, u, Xₙ, N, M);\n\n# Можно нарисовать пятый шаг по времени\nmake_plot(u, Xₙ, Tₘ, 5, ϕl, ϕr, f1, f2)","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"Запись только mp4 вместе с вырожденными корнями","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"make_gif(u, Xₙ, Tₘ, ϕl, ϕr, f1, f2; frame_skip = div(M,50), frames_to_write=M,\n         convert2mp4 = true, name=\"example_direct_with_f1_f2.gif\")\nnothing #hide","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"(Image: solution mp4 with degenerated)","category":"page"},{"location":"generated/example_direct/#","page":"Пример","title":"Пример","text":"","category":"page"}]
}
