var documenterSearchIndex = {"docs":
[{"location":"direct/experimental_data/#Генерация-экспериментальной-информации-1","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"","category":"section"},{"location":"direct/experimental_data/#Вырожденные-решения-1","page":"Генерация экспериментальной информации","title":"Вырожденные решения","text":"","category":"section"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Положив малый параметр varepsilon = 0 равным нулю, на каждом временном шаге определим задачи Коши для левого вырожденного решения varphi_l(x) и правого varphi_r(x) следующим образом","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"left\nbeginarrayc\n     fracd phi_l^mdx = q(x)  quad x in (0 1 \n     phi_l^m = u_l^m \nendarray\nright\nqquad\nleft\nbeginarrayc\n     fracd phi_r^mdx = q(x) quad x in 0 1) \n     phi_r^m = u_r^m\nendarray\nright","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Эти обыкновенные дифференциальные уравнения решим интегрированием:","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"left\nvarphi_0 = varphi_b \nvarphi_n+1^m = varphi_n^m + (q_n+1 - q_n)(x_n+1 - x_n)  2\nright","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Где varphi_b – это соответствующее граничное условие, а x_n узлы сетки по пространству, поданной в соответствующем направлении.","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"tip: Tip\nЗаписать формулы интегрирования ОДУ нормально.","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Решением семейства этих задач Коши будут (varphi_l)_n^m (varphi_r)_n^m. Определим полуразность вырожденных решений varPhi_n^m = (varphi_r)_n^m - (varphi_l)_n^m2 + (varphi_l)_n^m","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Положение переходного слоя f_1(t) определяется как аргумент x_tp при котором функция u(xt) пересекается с полуразностью вырожденных решений varPhi. Имея сеточные значения u_n^m varPhi_k^m, где функции определены на разных сетках, сначала нужно привести их к значениям на одной сетке. После чего, построить сеточную функцию v_k = u_k^m - varPhi_k^m, после чего найти ноль функции v_k. Ноль функции находится с помощью интерполяции обратной функции v_k^-1(0).","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Или в другой постановке:","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"f_1(t) equiv x_tp(t) = argmin_x u(xt) - varPhi(xt)","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Зная положение переходного слоя, интерполяцией найдём значение искомой функции на переходном слое f_2(t) = u(x_tp(t) t).","category":"page"},{"location":"direct/experimental_data/#Программная-реализация-1","page":"Генерация экспериментальной информации","title":"Программная реализация","text":"","category":"section"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Задачи коши решаются phidetermination. Для правого вырожденного   решения необходимо подать ключевое слово reverseX = true, чтобы   сигнализировать о обратном направлении интегрирования по x.   Решение находится интегрированием по квадратурным формулам парабол.\nПолуразность находится тривиальной функцией Φ.\nПоложение переходного слоя определяется функцией f1, которая в   каждый момент времени вызывает функцию   NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros,   которая реализует вышеописанный алгоритм поиска нуля функции.\nЗначения функции на переходном слое определяется f2, которая   так же вызывает   NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros   в каждый момент времени, только с другими аргументами.","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"tip: Tip\nМатематически формализоваться эту задачу через поиск нуля \"новой\" функции.","category":"page"},{"location":"direct/experimental_data/#","page":"Генерация экспериментальной информации","title":"Генерация экспериментальной информации","text":"Всё это вместе, одной строчкой, делается с помощью   generate_obs_data.","category":"page"},{"location":"functional/functional/#Обратная-задача-1","page":"Обратная задача","title":"Обратная задача","text":"","category":"section"},{"location":"functional/functional/#Функционал-1","page":"Обратная задача","title":"Функционал","text":"","category":"section"},{"location":"functional/functional/#","page":"Обратная задача","title":"Обратная задача","text":"Jq = intlimits^T_0 left( u(f_1(t) t q) - f_2(t) right)^2 dt + alpha\nintlimits_0^1 left( q(x) right)^2 dx","category":"page"},{"location":"functional/functional/#","page":"Обратная задача","title":"Обратная задача","text":"где f_1 f_2 — априорная информация, которая была единожды вычислена до итерационного процесса, при известном q(x), alpha — параметр регуляризации, пока равный нулю.","category":"page"},{"location":"functional/functional/#","page":"Обратная задача","title":"Обратная задача","text":"После вычисления сеточных значения u(xt q^s) на сетках Xₙ Tₘ нам необходимо найти значение искомой функции на переходном слое u( f_1(t) t q).","category":"page"},{"location":"functional/functional/#function-gradient-1","page":"Обратная задача","title":"Градиент функционала","text":"","category":"section"},{"location":"functional/functional/#","page":"Обратная задача","title":"Обратная задача","text":"Jq^s(x) = intlimits_0^T u^(s) (xt) psi^(s)(xt) dt","category":"page"},{"location":"direct/direct/#Прямая-задача-1","page":"Прямая задача","title":"Прямая задача","text":"","category":"section"},{"location":"direct/direct/#direct-formulation-1","page":"Прямая задача","title":"Постановка прямой задачи","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Прямая задача представляет из себя параболическое уравнение типа реакция-адвекция-диффузия для отрезка 01 с граничными условиями первого рода, где искомая функция u(xy) подлежит определению на полуинтервале (0 T","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 -\n    fracpartial upartial t = -u fracpartial upartial x +\n    q(x)u quad x in (01) quad t in (0T \n    u(0t) = u_l(t) quad u(1t) = u_r(t) quad t in (0T \n    u(xt) = u_i(x) qquad x in 01 t=0\nendaligned\nright","category":"page"},{"location":"direct/direct/#Схема-решения-1","page":"Прямая задача","title":"Схема решения","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Схема решения будет подробно объяснена на равномерной сетке. Формулы для неравномерной сетки будет даны без объяснений. В обоих случаях будет использоваться метод жестких прямых для сведения уравнения в частных производных к системе обыкновенных дифференциальных уравнений. После чего, последняя будет решаться с помощью одностадийной схемы Розенброка с комплексными коэффициентами (CROS1).","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Введём равномерную сетку X_N с N интервалами по пространственной переменной x с шагом h = 1N: X_N = lbrace x_n 0 le n le N x_n = n h rbrace. Произведём конечно-разностную аппроксимацию пространственных производных, перенесём всё в правую часть, так, чтобы слева осталась только производная по времени и получим дифференциально-алгебраическую систему, где количество неизвестных u_n equiv u_n(t) equiv u(x_n t) n = overline0 N равняется N+1.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"left\n    beginaligned\n     fracd ud t = varepsilon fracu_n+1 - 2 u_n + u_n-1h^2 +\n    u_n fracu_n+1 - u_n-12h - q_n u_n quad n = overline1 N-1 t in\n    (0 T \n     u_0 = u_l(t) u_N = u_r(t) quad t in (0 T \n     u(x_n 0) = u_i(x_n) quad x in 0 1 t =0\n    endaligned\nright","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Теперь сведём полученную дифференциально-алгебраическую систему к системе обыкновенных дифференциальных уравнений их N-1 уравнений с N-1 неизвестной путем подстановки алгебраических выражений для u_0 u_N в правую часть дифференциальных уравнений","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"left\nbeginaligned\n     fracdudt = fracu_2 - 2 u_1 + u_l(t)h^2 + u_1\n    fracu_2 - u_l(t)2h - q_1 u_1 quad t in (0 T \n     fracd ud t = varepsilon fracu_n+1 - 2 u_n + u_n-1h^2 +\n    u_n fracu_n+1 - u_n-12h - q_n u_n quad n = overline2 N-2\n    t in (0 T \n     fracdudt = varepsilon fracu_r(t) - 2 u_N-1 + u_N-2h^2 +\n    u_N-1 fracu_r(t) - u_N-22h - q_N-1 u_N-1 quad t in (0 T\n     u_n(0) = u_i(x_n) quad n = overline0 N \nendaligned\nright","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Введём новый вектор искомой функции mathbfy = (u_1 u_2 dots u_N-1)^T, тогда можно записать систему в следующем виде:","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    left\n    beginaligned\n        fracd mathbfyd t = mathbff  (mathbfyt) quad t in (0T\n        mathbfy(0) = mathbfy_i\n    endaligned\n    right","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"где","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    beginaligned\n        mathbfy = big(u_1  u_2   ldots  u_N - 1 big)^T \n        mathbff = big(f_1  f_2  ldots  f_N - 1big)^T \n        mathbfy_i = big(u_i (x_1)  u_i (x_2)  ldots  u_i (x_N - 1) big)^T\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"вектор-функция правой части mathbff определяется следующим образом:","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"mathbff = left\n    beginaligned\n        f_1 =       varepsilon fracy_2     - 2y_1  + u_l(t)h^2\n        + y_1       fracy_2        - u_l(t)2h - q(x_1) y_1 \n\n        f_n =       varepsilon fracy_n + 1 - 2y_n  + y_n - 1h^2\n        + y_n       fracy_n + 1    - y_n - 12h   - q(x_n) u_n\n        quad n=overline2 N-2 \n\n        f_N - 1 = varepsilon fracu_r(t) - 2y_N - 1 + y_N - 2h^2\n        + y_N - 1 fracu_r(t) - y_N - 22h   - q(x_N-1) y_N-1\n    endaligned\n    right","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Введём равномерную сетку по времени T_M с шагом tau = TM, состоящую из M интервалов и M+1 точек: T_M = lbrace t_m 0 le m le M t_m = tau m rbrace.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Записав однастадийную схему Розенброка, ешение на следующем временном определяется как","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"    beginaligned\n        mathbfy(t_m + 1) = mathbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbfw\n    endaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"где w находится","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"beginaligned\n    leftmathbfE - alpha  (t_m + 1 - t_m)  mathbff_mathbfyBig(mathbfy(t_m)t_mBig)right  mathbfw_1 = \n    qquadqquadqquadqquadquad = mathbff  Big(mathbfy(t_m)fract_m + 1 + t_m2Big)\nendaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"mathbff_mathbfy(mathbfy(t_m) t_m) — якобиан функции f по вектору y(t_m), где члены явно зависящие от времени взяты при t_m. Эта матрица Якоби имеет следующие ненулевые элементы.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"beginaligned\n     left(f_yright)_11   equiv  fracpartial f_1partial y_1  =  varepsilonfrac-2h^2 - fracy_2 - u_l(t)2h + q(x_1) \n\n      left(f_yright)_nn - 1   equiv  fracpartial f_npartial y_n - 1  =  varepsilon frac1h^2 + fracy_n2h quad n=overline2 N-1\n\n      left(f_yright)_nn   equiv  fracpartial f_npartial y_n  =   -varepsilon frac2h^2 - fracy_n+1 - y_n-12h + q(x_n) quad n=overline2 N-2\n\n      left(f_yright)_nn + 1   equiv  fracpartial f_npartial y_n + 1  =  varepsilon frac1h^2 - fracy_n2h quad n=overline1 N-2\n\n      left(f_yright)_N - 1N - 1   equiv  fracpartial f_N - 1partial y_N - 1  =   varepsilon frac-2h^2 - fracu_r(t) - y_N - 22h + q(x_N-1)\nendaligned","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Если от нас потребуется использовать сеточные значения u_l(t) u_r(t) q(x), то используются соответствующие сетки заменим их на u_l^m u_r^m q_n соответственно.","category":"page"},{"location":"direct/direct/#Случай-неравномерной-сетки-1","page":"Прямая задача","title":"Случай неравномерной сетки","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Введение неравномерной сетки необходимо для эффективной обработки случаев, когда малый параметр varepsilon начинает приобретать достаточно большой порядок малости, и вычисления на равномерной сетке становятся слишком долгими. Тогда мы сгустим сетку в окрестностях особенностей решения. В дальнейшем мы будем использовать кусочно-равномерную сетку, но формулы запишем в общем виде для неравномерных сеток.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Подход к решению остаётся неизменным, нужно лишь модифицировать формулы mathbff и mathbfF_mathbfy для неравномерной сетки. Запишем их с использованием сеточных значений u_l^m u_r^m q_n.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"mathbff = left\nbeginaligned\n        f_1 =  frac2 varepsilonx_2 - x_0 left(\n              fracy_2 - y_1x_2 - x_1\n            - fracy_1 + u_l^mx_1 - x_0\n        right)\n        + y_1 fracy_2 - u_l^mx_2 - x_0 - q_1 y_1 \n\n        f_n =  frac2 varepsilonx_n+1 - x_n-1\n        left(\n              fracy_n+1 - y_nx_n+1 - x_n\n            - fracy_n + y_n-1x_n - x_n-1\n        right)\n        + y_n  fracy_n + 1 - y_n - 1x_n+1 - x_n-1\n        - q_n u_n quad n=overline2 N-2 \n\n        f_N - 1 =  frac2 varepsilonx_N - x_N-1\n        left(\n              fracu_r^m - y_N - 1x_N - x_N-1\n            - fracy_N-1 + y_N - 2x_N-1 - x_N-2\n        right)\n        + y_N - 1 fracu_r^m - y_N - 2x_N - x_N-2\n        - q_N-1 y_N-1\nendaligned\nright","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Ненулевые элементы матрицы Якоби","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"beginaligned\n    (f_y)_1 1           =\n    frac2 varepsilonx_2 - x_0\n    left(\n        frac-1x_2 - x_1 - frac1x_1 - x_0\n    right)\n    + fracy_2 - u_l^mx_2 - x_0 - q_1 \n\n    (f_y)_n n - 1       =\n    frac2 varepsilonx_n+1 - x_n-1\n    left(\n        frac1x_n - x_n-1\n    right)\n    - fracy_nx_n+1 - x_n-1 quad n=overline2 N-1\n\n    (f_y)_n n           =\n    frac2 varepsilonx_n+1 - x_n-1\n    left(\n        frac-1x_n+1 - x_n - frac1x_n - x_n-1\n    right)\n    + fracy_n+1 - y_n-1x_n+1 - x_n-1 - q_n quad n=overline2 N-2\n\n    (f_y)_n n + 1       =\n    frac2 varepsilonx_n+1 - x_n-1\n    left(\n        frac1x_n+1 - x_n\n    right)\n    + fracy_nx_n+1 - x_n-1 quad n=overline1 N-2\n\n    (f_y)_N - 1N - 1  =\n    frac2 varepsilonx_N - x_N-2\n    left(\n        frac-1x_N - x_N-1 - frac1x_N-1 - x_N-2\n    right)\n    + fracu_r^m - y_N - 2x_N - x_N-2 - q_N-1\nendaligned","category":"page"},{"location":"direct/direct/#Случай-динамической-сетки-1","page":"Прямая задача","title":"Случай динамической сетки","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"В дальнейшем, мы построим алгоритм определения положения переходного слоя.","category":"page"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"tip: Tip\nИзменение алгоритма при динамической сетке Ну собственно здесь нужно нормально всё описать","category":"page"},{"location":"direct/direct/#Программная-реализация-1","page":"Прямая задача","title":"Программная реализация","text":"","category":"section"},{"location":"direct/direct/#","page":"Прямая задача","title":"Прямая задача","text":"Функция правой части   NonLinearReactionAdvectionDiffusionWithFrontData.directRP.\nФункция якобиана   NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y,   возвращает матрицу типа Tridiagonal (см. официальную   документацию)\nФункция якобиана, вычисляемого автоматическим дифференцированием   NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y   ForwardDiff.jl\nФункция поиска решения по схеме CROS1 solve.","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/adjoint/check/dt_adjoint.jl\"","category":"page"},{"location":"generated/helpers/doctest_adjoint/#Непосредственная-реализация-проверки-сопряженной-задачи-1","page":"-","title":"Непосредственная реализация  проверки сопряженной задачи","text":"","category":"section"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\n\n# Юнит тест проверяет корректность решения прямой задачи.\n# Алгоритм описан в /docs/src/direct/adjoint_check.md\n# Возвращает решение, аналитическое решение, сетку по X, сетку по T.\n\nusing NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: heterogeneity, adjointRP, ∂ARP_∂y;\n\nusing ForwardDiff;\n\n# Сначала, сгенирируем экспериментальные данные, на увеличенном числе узлов.\nu_l(t) = -8\nu_r(t) =  4\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0.0, 0.28;              # Область по T\nN, M = 250, 500;                # Увеличенное Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);              # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nu₀ = u_init.(Xₙ);               # Начальные условия\n#\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Серединный корень\nf1_data = f1(ϕ, u, Xₙ, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, Xₙ, N, M);                                 # Значение функции на переходном слое\n\n# Решение сопряженной задачи\n\n\n# Теперь переходим непосредственно к проверке\n# Модельная функция\nraw\"\"\"\n    g(n::Int, X = Xₙ, N::Int,\n        m::Int, T = Tₘ, M::Int) -> Real\n\nМодельная функция ``(1-2t)\\sin(\\pi x)``.\n`n` — номер узла в сетке по X. `m` — номер шага в сетке по T.\n`X` — сетка по X, `N` — кол-во **интервалов** сетки.\n`Tₘ` — сетка по T, `M` — кол-во **интервалов** сетки.\nЗахватывает переменную `T` конечное время моделирования из окружения.\n\"\"\"\nfunction g(n::Int, X, N::Int,\n            m::Int, Tₘ, M::Int)\n    t = Tₘ[m]\n    x = X[n]\n    return (1 - 2t/T)*sin(π*x)\nend\n\n# Выберем априорный параметр аппроксимации дельта-функции\nω = 0.0001;\nraw\"\"\"\n    g_d(n::Int, Xₙ::Vector, N::Int,\n        m::Int, Tₘ::Vector, M::Int,\n        ε::Real, qₙ::Vector,\n        u::Matrix, f1::Vector, f2::Vector) -> Real\n\nВычисляет невязку, т.е. рез ультат подстановки ``g`` в постановку сопряженной задачи.\n`n` — номер узла в сетке по X. `m` — номер шага в сетке по T.\n`X` — сетка по X, `N` — кол-во **интервалов** сетки.\n`Tₘ` — сетка по T, `M` — кол-во **интервалов** сетки.\n\"\"\"\nfunction g_d(n::Int, Xₙ::Vector, N::Int,\n                m::Int, Tₘ::Vector, M::Int,\n                ε::Real, qₙ::Vector,\n                u::Matrix, f1::Vector, f2::Vector,\n               w::Real)\n    x = Xₙ[n];\n    t = Tₘ[m];\n    out  = 2/T * sin(π * x) - ( - ε * π^2 * (1 - 2t/T) * sin(π * x)) + π * (1 - 2t/T) * cos(π * x) * u[n,m] + qₙ[n] * (1 - 2t/T) * sin(π * x) - heterogeneity(n, m, Xₙ[2:N], N, Tₘ, M, u, f1, f2, w)\n    return out;\nend\n\nUₙₘ = u;                                        # Сохраним матрицу решения прямой задачи\nψl = [0.0 for i in 1:M+1];                      # Левые  ГУ для модельной функции\nψr = [0.0 for i in 1:M+1];                      # Правые ГУ для модельной функции\nψ₀ = [g(n, Xₙ, N, M+1, Tₘ, M) for n in 1:N+1];  # Начальные условия для модельной функции\n# Внимание! сопряженная задача — ретроспективная\n# ``u₀ = g(x, T)``\n# Модельное решение найденное с помощью известного аналитического решения\n# Для его генерации используем инвертированную сетку по времени, чтобы\n# массив `ψ_model` и `ψ` имели одно и тоже направление хода времени.\nψ_model = [ g(n, Xₙ, N, m, Tₘ, M) for n in 1:N+1, m in M+1:-1:1];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nraw\"\"\"\n    RP(y, m, Xₙ, N, Tₘ, M, ε, qₙ, u, f1, f2) -> Vector\n\n# Return\n    Вектор размера `N-1`, сеточные значения правой части уравнения,\n    для которого `g(x,t)` будет являться решением.\n\n!!! warning\n    Функция не предназначена для самостоятельного использования,\n    она передается в качестве аргумента в `solve`, внутри которой\n    для нее сформуются аргументы нужной длины, для которых не\n    потребуется смещений индексов.\n\"\"\"\nfunction RP(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, u, f1, f2, w)\n    arp = adjointRP(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, u, f1, f2, w)\n    d = [ g_d(n, Xₙ, N, m, Tₘ, M, ε, qₙ, u, f1, f2, w) for n in 1:N-1]\n    return arp .- d\nend\n# Якобиан сконструируем тем же способом, что и внутри пакета в `src/adjoint.jl`.\nj(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, U, f1, f2, w) = ForwardDiff.jacobian( z -> adjointRP(z, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, U, f1, f2, w), y)\n\n# С использованием автоматического дифференцирования\nψ = solve_adjoint(ψ₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, RP, j, w = ω)\n@test all(isapprox.(ψ_model, ψ, atol = 0.025))\n\n# С использованием трехдиагонального якобиана\nψ = solve_adjoint(ψ₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, RP, ∂ARP_∂y, w = ω)\n@test all(isapprox.(ψ_model, ψ, atol = 0.025))\n\n(ψ, ψ_model, Xₙ, Tₘ)\nnothing #hide","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(ψ, Xₙ, Tₘ, dd, dd, dd, d, d, ψ_model; name = \"direct_check.gif\")","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"err = ψ .- ψ_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/helpers/doctest_adjoint/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"adjoint/adjoint/#adjoint-1","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"section"},{"location":"adjoint/adjoint/#Постановка-сопряженной-задачи-1","page":"Сопряженная задача","title":"Постановка сопряженной задачи","text":"","category":"section"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача формулируется следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 psipartial x^2 +\n    fracpartial psipartial t =\n    u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t))\n    quad x in (01) quad t in (0T \n\n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T \n\n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Причем, важной особенностью численной реализации решения сопряженной задачи, является динамическая, неравномерная по x сетка, уникальная для каждого шага по времени. Эту сетку возвращается нам функция solve решения прямой задачи.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача является ретроспективной. Она должна использоваться переданную ей сетку X_N^M в обратном по времени направлении. Найдя решение на следующем временном слое psi^m-1 мы должны аппроксимировать его на соответствующую новому временному слою сетку X_N^m-1.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Введем следующие обозначения","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Описание Обозначение\nвектор столбец искомой функции размерностью N-1: mathbfy = (psi_1 psi_2 dots psi_N-1)^T.\nвектор столбец начальных значений размерностью N-1: mathbfy_0 = (0 0 dots 0)^T.\nвектор столбец правой части размерность N-1: mathbff(mathbfy t)","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Приведём только формулы для неравномерной сетки.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача легко приводится к виду","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    left\n    beginaligned\n        fracd mathbfyd t = mathbff  (mathbfyt) quad t in t_0T)\n        mathbfy(T) = mathbfy_init\n    endaligned\n    right","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Хоть граничные условия у нас и нулевые psi_r(t) = psi_l(t) = 0, в формулах выпишем их явно. Причем f^m вычисляется с использованием X_N^m.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"mathbff = left\nbeginaligned\n        f_1 =  frac-2 varepsilonx_2 - x_0 left(\n              fracy_2 - y_1x_2 - x_1\n            - fracy_1 + psi_l^mx_1 - x_0\n        right)\n        + y_1 fracy_2 - psi_l^mx_2 - x_0\n        + q_1 y_1 - 2 delta( x_1 - f_1^m)) ( u_n^m - f_2^m) \n\n        f_n =  frac-2 varepsilonx_n+1 - x_n-1\n        left(\n              fracy_n+1 - y_nx_n+1 - x_n\n            - fracy_n + y_n-1x_n - x_n-1\n        right)\n        + y_n  fracy_n + 1 - y_n - 1x_n+1 - x_n-1\n        + q_n u_n - 2 delta( x_n - f_1^m)) ( u_n^m - f_2^m)\n        quad n=overline2 N-2 \n\n        f_N - 1 =  frac-2 varepsilonx_N - x_N-1\n        left(\n              fracpsi_r^m - y_N - 1x_N - x_N-1\n            - fracy_N-1 + y_N - 2x_N-1 - x_N-2\n        right)\n        + y_N - 1 fracpsi_r^m - y_N - 2x_N - x_N-2\n        + q_N-1 y_N-1 - 2 delta( x_N-1 - f_1^m)) ( u_n^m - f_2^m)\nendaligned\nright","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Ненулевые элементы Якобиана mathbfF_mathbfy","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    (f_y)_1 1           =\n    frac-2 varepsilonx_2 - x_0\n    left(\n        frac-1x_2 - x_1 - frac1x_1 - x_0\n    right)\n    + q_1 \n\n    (f_y)_n n - 1       =\n    frac-2 varepsilonx_n+1 - x_n-1\n    left(\n        frac1x_n - x_n-1\n    right)\n    - fracu_n^mx_n+1 - x_n-1 quad n=overline2 N-1\n\n    (f_y)_n n           =\n    frac-2 varepsilonx_n+1 - x_n-1\n    left(\n        frac-1x_n+1 - x_n - frac1x_n - x_n-1\n    right)\n    + q_n quad n=overline2 N-2\n\n    (f_y)_n n + 1       =\n    frac-2 varepsilonx_n+1 - x_n-1\n    left(\n        frac1x_n+1 - x_n\n    right)\n    + fracu_n^mx_n+1 - x_n-1 quad n=overline1 N-2\n\n    (f_y)_N - 1N - 1  =\n    frac-2 varepsilonx_N - x_N-2\n    left(\n        frac-1x_N - x_N-1 - frac1x_N-1 - x_N-2\n    right)\n    + q_N-1\nendaligned","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nПравая часть в уравнении для mathbfw в явном виде не зависит от t, а все сеточные функции u, f_1, f_2 берутся в момент времени t_m, вместо frac t_m+1 + t_m2.","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Найдем решение сопряженной задачи следующим образом:","category":"page"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    beginaligned\n         mathbfy(t_m - 1) = mathbfy(t_m) + (t_m - t_m-1) \n        mathrmRe  mathbfw \n\n         leftmathbfE - frac1 + i2  (t_m - t_m-1) \n        mathbfF_mathbfyBig(mathbfy(t_m)t_mBig)right \n        mathbfw = \n\n         qquadqquadqquadqquadquad = mathbff \n        Big(mathbfy(t_m) t_mBig)\n    endaligned","category":"page"},{"location":"adjoint/adjoint/#Программная-реализация-1","page":"Сопряженная задача","title":"Программная реализация","text":"","category":"section"},{"location":"adjoint/adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Функция неоднородности   NonLinearReactionAdvectionDiffusionWithFrontData.heterogeneity.\nКонечно-разностная аппроксимация дельта функции   NonLinearReactionAdvectionDiffusionWithFrontData.deltaw.\nФункция правой части   NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP.\nФункция якобиана   NonLinearReactionAdvectionDiffusionWithFrontData.∂ARP_∂y, возвращает   матрицу типа Tridiagonal (см. официальную   документацию)\nФункция якобиана, вычисляемого автоматическим дифференцированием   NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y   ForwardDiff.jl\nФункция поиска решение по схеме CROS1 solve_adjoint.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/direct/direct_examples.jl\"","category":"page"},{"location":"generated/docexample_direct/#Примеры-1","page":"Примеры","title":"Примеры","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"На этой странице мы делаем include примеров, которые лежат в корневом каталоге пакета в папке \"examples/\".","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Literate.jl включает текст этих примеров и в md файл.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Pages = [ \"docexample_direct.md\" ]\nDepth = 5","category":"page"},{"location":"generated/docexample_direct/#de_1-1","page":"Примеры","title":"Пример №1, подробный, статическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"вручную задаются входные параметры,\nрешается прямая задача,\nгенерируются экспериментальные данные.","category":"page"},{"location":"generated/docexample_direct/#Решение-прямой-задачи-1","page":"Примеры","title":"Решение прямой задачи","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"# Здесь мы зададим параметры вручную, дав комментарии о них.\n# После, во всех следующих примерах,\n# будем задавать параметры с помощью стандартной функции [`NonLinearReactionAdvectionDiffusionWithFrontData.dparams`](@ref)\n\nusing NonLinearReactionAdvectionDiffusionWithFrontData\n\nu_l(t) = -8 + sin(2*π / T * t); # Прямая задача может быть с неоднородными ГУ\nu_r(t) =  4 +4sin(-2*π / T * t);# Но в дальнейшем, будем использовать только однородные.\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый известный коэффициент, который\n                                # и будем определять имея априорную информацию.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.28;                # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =     qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nu₀ = u_init.(Xₙ);               # Начальные условия\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Все массивы передаются внутрь функции solve полностью, вместе с граничными точками. Внутри, они локально модифицируются, и на вход NonLinearReactionAdvectionDiffusionWithFrontData.directRP, NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y подаются без граничных точек.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"u, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Генерация-априорной-информации-1","page":"Примеры","title":"Генерация априорной информации","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"# Здесь у нас все просто, сетка статическая, жизнь прекрасна.\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                      # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true);     # Нужно сигнализировать, о интегрировании в\n                                                                        # обратном направлении вдоль оси ``X``.\n                                                                        # Ответ нам вернут в обычном направлении.\nϕ       = Φ(ϕl, ϕr, N, M);                                              # Полуразность вырожденных корней\nf1_data = f1(ϕ, u, Xₙ, N, M);                                           # Положение переходного слоя\nf2_data = f2(f1_data, u, Xₙ, N, M);                                     # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#Визуализация-1","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Мы не можем строить большие анимации на стороне Travis-a. Если мы на CI, то будем рисовать только 10 кадров. Если мы генерируем документацию локально, то рисуем 80 кадров.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"isTravis = in(\"Travis\", keys(ENV))\nftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];\n\n# Запись gif одного только решения\nmake_gif(u, XX, Tₘ; name=\"solution_direct_ex1.gif\", frames_to_write = ftw)\n\n# Запись **только** mp4 вместе с вырожденными корнями и переходным слоем.\nmake_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data;\n         name=\"solution_direct_ex11.mp4\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_2-1","page":"Примеры","title":"Пример №2, краткий, стандартные параметры","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"получаем стандартные входные параметры,\nрешается прямая задача,\nгенерируются экспериментальные данные.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Только в отличии от Подробного примера №1 будем пользоваться функциями-сокращениями.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Этот файл будет использоваться в тестировании.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Задаем параметры с помощью стандартной функции NonLinearReactionAdvectionDiffusionWithFrontData.dparams","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\n\na, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀ = NonLinearReactionAdvectionDiffusionWithFrontData.dparams();\n#\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Генерируем экспериментальные данные функцией NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ϕl, ϕr, ϕ, f1_data, f2_data = generate_obs_data(u, Xₙ, N, Tₘ, M, qₙ, ulₘ, urₘ);\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#Визуализация-2","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для стандартных данных.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"make_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"solution_direct_ex2.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_3-1","page":"Примеры","title":"Пример №3, развернуты, динамическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"В этом примере:","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"вручную задаём параметры для динамической сетки,\nрешается прямая задача,\nгенерируются экспериментальные данные на динамической сетке.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: shishkin_mesh;\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Заданием-параметров-для-динамической-сетки-1","page":"Примеры","title":"Заданием параметров для динамической сетки","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"u_l(t) = -8;                    # ГУ\nu_r(t) =  4;                    #\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.01;                       # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.42;                # Область по T\nx_tp = 0.12;                    # Положение переходного слоя\nM = 500;                        # Кол-во разбиений по X, T\nτ = (T-t₀)/M;                   # шаг по T\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Создание-и-решение-в-случае-динамической-сетки-1","page":"Примеры","title":"Создание и решение в случае динамической сетки","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Новое поведение будет реализоваться с помощью передачи функции создания сетки внутрь solve в качестве аргумента. Эта функция должна принимать только один аргумент — положение переходного слоя и формировать соответствующую сетку. В пакете есть формирование кусочно-равномерной сетки со сгущениями на границе и на переходном слое. Создадим замыкание этой функции, которое будет иметь нужную сигнатуру.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"mshfrm(x_tp) = shishkin_mesh(a, b, x_tp, ε, 40, 0.5, 1.0, 1.0, 0.25);\nXₙ = mshfrm(x_tp); ;                            # Сетка по Х\nN  = length(Xₙ) - 1                             # Примем за N длину сетки, что получилась в итоге.\nqₙ =    qf.(Xₙ);                                # Сеточные значения коэффициента линейного усиления\nu₀ = u_init.(Xₙ, ε=ε, x_tp = x_tp);             # Начальные условия\n\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, create_mesh = mshfrm);\nnothing #hide","category":"page"},{"location":"generated/docexample_direct/#Генерация-априорной-информации-2","page":"Примеры","title":"Генерация априорной информации","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Полуразность вырожденных корней\nϕ       = apply_on_dynamic_mesh(ϕ, XX, N, M);                       # Аппроксимация на переменную сетку\nϕl      = apply_on_dynamic_mesh(ϕl, XX, N, M);                      # Аппроксимация на переменную сетку\nϕr      = apply_on_dynamic_mesh(ϕr, XX, N, M);                      # Аппроксимация на переменную сетку\nf1_data = f1(ϕ, u, XX, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, XX, N, M);                                 # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#Визуализация-3","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для динамической сетке","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ftw = [1; 2:div(M+1, 80):M+1];\nmake_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"solution_direct_ex3.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#de_4-1","page":"Примеры","title":"Пример №4, краткий, динамическая сетка","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Делаем тоже самое, что в развернутом примере №3, только с использованием функций сокращений и стандартных параметров.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: shishkin_mesh;\n\n# Задача параметров и решение в коротком виде\na, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀, mshfrm_std = NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform();\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, create_mesh = mshfrm_std);\nnothing #hide\n\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Полуразность вырожденных корней\nϕ       = apply_on_dynamic_mesh(ϕ, XX, N, M);                       # Аппроксимация на переменную сетку\nϕl      = apply_on_dynamic_mesh(ϕl, XX, N, M);                      # Аппроксимация на переменную сетку\nϕr      = apply_on_dynamic_mesh(ϕr, XX, N, M);                      # Аппроксимация на переменную сетку\nf1_data = f1(ϕ, u, XX, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, XX, N, M);                                 # Значение функции на переходном слое\nnothing # hide","category":"page"},{"location":"generated/docexample_direct/#Визуализация-4","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"Так выглядит решение для стандартных данных динамической сетке.","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"ftw = [1; 2:div(M+1, 80):M+1];\nmake_gif(u, XX, Tₘ, ϕl, ϕr, ϕ, f1_data, f2_data; name=\"solution_direct_ex4.gif\", frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"","category":"page"},{"location":"generated/docexample_direct/#","page":"Примеры","title":"Примеры","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/adjoint/adjoint_examples.jl\"","category":"page"},{"location":"generated/docexample_adjoint/#Примеры-1","page":"Примеры","title":"Примеры","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"На этой странице мы делаем include примеров, которые лежат в корневом каталоге пакета в папке \"examples/\".","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Literate.jl включает текст этих примеров и в md файл.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Pages = [ \"docexample_adjoint.md\" ]\nDepth = 5","category":"page"},{"location":"generated/docexample_adjoint/#Пример-1,-подробный,-статическая-сетка-1","page":"Примеры","title":"Пример №1, подробный, статическая сетка","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Сопряженная задача определяется для сеточного решения некоторой прямой задачи, и некоторых априорных данных. Поэтому, сначала необходимо сгенерировать априорные данные и некоторую матрицу u. Сделаем это на увеличенном числе интервалов, т.к. решение сопряженной задачи менее гладкое.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\n\nu_l(t) = -8\nu_r(t) =  4\nq(x) = 4*sin(3 * π * x);        # Коэффициент линейного усиления, который в обратной\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"задаче необходимо определить, но при генерации априорной информации мы задаем некоторый коэффициент, который, собственно, после имея априорную информацию и будем определять.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"ε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.28;                # Область по T\nN, M = 50, 80;                  # Увеличенное Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      q.(Xₙ);               # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\ny₀ = u_init.(Xₙ);               # Начальные условия\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"u, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\nnothing #hide\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Нужно подать инвертированную сетку\nϕr      = reverse(ϕr, dims=1);                                      # А после — инвертировать решение по X\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Серединный корень\nf1_data = f1(ϕ, u, Xₙ, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, Xₙ, N, M);                                 # Значение функции на переходном слое\nnothing #hide\n\n# Решение сопряженной задачи\nUₙₘ = u;                        # Сохраним старую матрицу\ny₀ = [0.0 for i in 1:N+1];      # Нулевые начальные условия\nψl = [0.0 for i in 1:M+1];      # Нулевые ГУ\nψr = [0.0 for i in 1:M+1];      # Нулевые ГУ\n\nψ = solve_adjoint(y₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, w = 0.0005)\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#Визуализация-1","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Мы не можем строить большие анимации на стороне Travis-a. Если мы на CI, то будем рисовать только 10 кадров. Если мы генерируем документацию локально, то рисуем 80 кадров.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"isTravis = in(\"Travis\", keys(ENV))\nftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"На отрисовку, решение сопряженной задачи передадим в инвертированном времени. Передадим свою подпись к графиками с помощью keyword label=\"\\\\psi\", не забыл про экранировку спец символа","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"make_gif(reverse(ψ, dims=2), XX, Tₘ;\n         label=\"\\\\psi\",\n         name=\"solution_adjoint_ex1.gif\",\n         frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Результат должен быть около нулевой, ведь в качестве текущего приближения q мы взяли искомое, а при нем — градиент должен обнуляться.","category":"page"},{"location":"generated/docexample_adjoint/#Пример-3,-подробный,-динамическая-сетка-1","page":"Примеры","title":"Пример №3, подробный, динамическая сетка","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"# Сопряженная задача определяется для сеточного решения некоторой прямой задачи,\n# и некоторых априорных данных. Поэтому, сначала необходимо сгенерировать\n# априорные данные и некоторую матрицу `u`.\n# Сделаем это на увеличенном числе интервалов, т.к. решение сопряженной задачи\n# имеет более резкие фронты.\nusing NonLinearReactionAdvectionDiffusionWithFrontData\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: shishkin_mesh;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: apply_on_dynamic_mesh;\n\nu_l(t) = -8;                    # ГУ\nu_r(t) =  4;                    #\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления\nε = 0.03;                       # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 0.20;                # Область по T\nx_tp = 0.22;                    # Положение переходного слоя\nM = 500;                        # Кол-во разбиений по X, T\nτ = (T-t₀)/M;                   # шаг по T\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nnothing #hide\n\n# Новое поведение будет реализоваться с помощью передачи функции создания сетки внутрь `solve` в качестве аргумента.\n# Эта функция должна принимать только один аргумент — положение переходного слоя и формировать соответствующую сетку.\n# В пакете есть формирование кусочно-равномерной сетки со сгущениями на границе и на переходном слое.\n# Создадим замыкание этой функции, которое будет иметь нужную сигнатуру.\nmshfrm(x_tp) = shishkin_mesh(a, b, x_tp, ε, 40, 1.0, 1.0, 0.2, 1.0);\nXₙ = mshfrm(x_tp); ;                            # Сетка по Х\nN = length(Xₙ) - 1                              # Примем за N длину сетки, что получилась в итоге.\nqₙ =  1.0 * qf.(Xₙ);                            # Сеточные значения коэффициента линейного усиления\n                                                # чтобы посмотреть на поведение сопряженной задачи\n                                                # когда прямая задача не соответствует наблюдаемым данным,\n                                                # измените этот массив. Например qₙ =  0.2 * qf.(Xₙ);\nu₀ = u_init.(Xₙ, ε=ε, x_tp = x_tp);             # Начальные условия\n#\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, create_mesh = mshfrm);\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ,Xₙ, N, Tₘ, M, reverseX = true);  # Нужно подать инвертированную сетку и q\nϕr      = reverse(ϕr, dims=1);                                      # А после — инвертировать решение по X\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Полуразность вырожденных корней\nϕ       = apply_on_dynamic_mesh(ϕ, XX, N, M);                       # Аппроксимация на переменную сетку\nϕl      = apply_on_dynamic_mesh(ϕl, XX, N, M);                      # Аппроксимация на переменную сетку\nϕr      = apply_on_dynamic_mesh(ϕr, XX, N, M);                      # Аппроксимация на переменную сетку\nf1_data = f1(ϕ, u, XX, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, XX, N, M);                                 # Значение функции на переходном слое\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Про эмпирический параметр и его выбор смотри следующий подраздел.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"w = 0.00015;       # Эмпирический параметр апроксимации дельта-функции\n\n\n\n# Решение сопряженной задачи\nUₙₘ = u;                        # Сохраним старую матрицу\nψ₀ = [0.0 for i in 1:N+1];      # Нулевые начальные условия\nψl = [0.0 for i in 1:M+1];      # Нулевые ГУ\nψr = [0.0 for i in 1:M+1];      # Нулевые ГУ\nψ = solve_adjoint(ψ₀, XX, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, w = w)\nnothing #hide","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Результат должен быть около нулевой, ведь в качестве текущего приближения q мы взяли искомое, а при нем — градиент должен обнуляться.","category":"page"},{"location":"generated/docexample_adjoint/#empiric-control-1","page":"Примеры","title":"Контроль параметра аппроксимации дельта-функции","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Проведем контроль выбора априорного параметра в аппроксимации дельта-функции. На точных данных, эта неоднородность должна быть нулевой почти везде исходя из следующих соображений:","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"сопряженная задача — ретроспективная,\nеё начальные условие — нулевые,\nесли из уравнения вычеркнуть эту неоднородность, то решением с такими ГУ и НУ будет тривиальное нулевое решение.\nисходя из формулировки градиента,\nнулевое решение сопряженной задачи даст нам нулевой градиент, а значит мы нашли решение обратной задачи.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"Выбор этого параметра значительно влияет на вычисление градиента, а значит и на решение, к которому сойдется итерационный процесс.","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"using  NonLinearReactionAdvectionDiffusionWithFrontData: heterogeneity;\nusing LaTeXStrings, Plots;\nUₙₘ = u[2:N, :];\nX = XX[2:N, :];\nH = [  - heterogeneity(n, m, X[:, m], N, Tₘ, M, Uₙₘ, f1_data, f2_data, w) for n in 1:N-1, m in 1:M+1]\nheatmap(H', title=L\"-2 δ( x - f_1(t))(u(f1(t), t) - f2(t) \")","category":"page"},{"location":"generated/docexample_adjoint/#Визуализация-2","page":"Примеры","title":"Визуализация","text":"","category":"section"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"ftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];\n\nmake_gif(reverse(ψ, dims=2), XX, Tₘ;\n         label=\"\\\\psi\",\n         name=\"solution_adjoint_ex3.gif\",\n         frames_to_write = ftw)","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"","category":"page"},{"location":"generated/docexample_adjoint/#","page":"Примеры","title":"Примеры","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Справочник-1","page":"Справочник","title":"Справочник","text":"","category":"section"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]\nPages = [\n    \"direct.jl\",\n    degenerated.jl\",\n    \"adjoint.jl\",\n    \"functional.jl\",\n    \"utils.jl\",\n    \"plotting.jl\"\n]","category":"page"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]\nPages = [\n    \"direct.jl\",\n    degenerated.jl\",\n    \"adjoint.jl\",\n    \"functional.jl\",\n    \"utils.jl\",\n    \"plotting.jl\"\n]","category":"page"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.NonLinearReactionAdvectionDiffusionWithFrontData","text":"module NonLinearReactionAdvectionDiffusionWithFrontData\n\nПакет реализует исследование в рамках гранта РФФИ #20-31-70016 \"Численные методы решения обратных задач для нелинейных сингулярно возмущённых уравнений типа реакция-диффузия-адвекция с данными о положении фронта реакции\".\n\nАвтор исходного кода пакета:\n\nАндрей Борзунов, Кафедра математики физического факультета МГУ им. Ломоносова.\n\nИсполнители гранта:\n\nМельникова Алина Александровна\nЛевашова Наталия Тимуровна\nЛукьяненко Дмитрий Витальевич (Руководитель)\nБыцюра Светлана Владимировна\nБорзунов Андрей Анатольевич\nИсаев Темур Фуркатович\nАргун Рауль Ларикович\nГорбачев Александр Викторович\n\nДокументация: https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl\n\n\n\n\n\n","category":"module"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J","text":"J(uˢ::Matrix, Xₙ::Array, N::Int,\n  Tₘ::Vector, M::Int,\n  f1::Vector, f2::Vector,\n  qₙˢ::Vector, α::Real = 0.0) -> Real\n\nВычисляет функционал J(mathbfx) = int_0^T left( u(f_1(t) t q^s) - f_2(t) right)^2 + alpha int_0^1 q^2(x) dx.\n\nИспользует f2 для вычисления u(f_1(t) t) и после по формуле трапеций.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J_q","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J_q","text":"J_q(uˢ::Matrix, ψˢ::Matrix,\n    Xₙ::Array, N::Int,\n    Tₘ::Vector, M::Int) -> Vector\n\nВычисляет градиент J_q(x) = int_0^T u^s(x t) psi^s(x t) dt.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.apply_on_dynamic_mesh-Tuple{Array{T,2} where T,Array{T,2} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.apply_on_dynamic_mesh","text":"apply_on_dynamic_mesh(ϕ::Matrix, XX::Matrix,\n                  N::Int, M::Int) -> Matrix\n\nАппроксимирует ϕ на динамичски изменяющуюся на каждом временном шаге сетку XX.\n\nФункция phidetermination определяют вырожденные корни на стартовой сетке.  Φ проиозводит линейные операции над векторами на каждом временном шаге, опять же на стартовой сетке. Поэтому если в расчетах была использована динамическая сетка, то нужно переопределить ϕ на этой динамической сетке.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.delta","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.delta","text":"delta(x, Xₙ, x₀ = 0) -> ::Real\n\nВычисляет конечно разностную аппроксимацию дельта функции delta(x x₀) на сетке Xₙ исходя из intlimits_a^b delta(x x₀) dx = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f1-Tuple{Array{T,2} where T,Array{T,2} where T,Array,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f1","text":"f1(ϕ::Matrix, u::Matrix, Xₙ::Array, N::Int, M::Int) -> Vector\n\nНаходит положение переходного слоя f_1(t) = x_tp(t) путем поиска точки пересечения аргумента, при котором пересекаются u(xt) и ϕ(x).\n\nТочка пересечения находится путем интерполяции функции обратной к u(xt) - ϕ(x) = 0, передавай аргументы в инвертированном виде в find_f_zeros.\n\nSee also: find_f_zeros\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f2-Tuple{Array{T,1} where T,Array{T,2} where T,Array,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f2","text":"f2(ϕ::Matrix, u::Matrix, Xₙ::Array, N::Int, M::Int) -> Vector\n\nНаходит значение искомой функции на переходном слое f_2(t) = u(x_tp t). Находится путем интерполяции функции u(x - f1(t) t) = 0.\n\nSee also: find_f_zeros\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data-Tuple{Array{T,2} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.generate_obs_data","text":"generate_obs_data(u::Matrix, Xₙ::Vector, N::Int,\n                  Tₘ::Vector, M::Int,\n                  qₙ::Vector,\n                  ulₘ::Vector, urₘ::Vector)\n\nФнукция-сокращение.\n\n#Return Левый вырожденный корень, правый, их полуразность, положение переходного слоя, значение u на переходном слое. ϕl, ϕr, ϕ, f1_data, f2_data\n\nSee also: phidetermination, Φ, f1, f2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","text":"make_gif(u::Matrix, Xₙ::Vector, Tₘ::Vector,\n              ϕ_l::Matrix = missings(2), ϕ_r::Matrix = missings(2),\n              f1::Vector = missings(2), f2::Vector = missings(2),\n              analitical = nothing;\n              frames_to_write::Int = -1,\n              name = \"solution.gif\",\n              convert2mp4 = false)\n\nРисует gif анимацию решения. вплоть по frames_to_write-ый кадр, сохраняет как \"results/name\".\n\nТак же рисует аналитическое решение analitic(x,t), если таково передано. label::String — LaTeX строка подписи искомой функции с экранирование спец. символов.\n\ntip: Tip\nPass an empty string to avoid saving at disk.\n\nTODO: Fix doc\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_minimzation_gif-Tuple{Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_minimzation_gif","text":"make_minimzation_gif(Js::Vector, Qs::Matrix,\n                     qₙ::Vector, Xₙ::Vector;\n                     frames_to_write::Vector = Vector(),\n                     name = \"solution.gif\", convert2mp4 = false,\n                     β::Real = 0.0)\n\nСохраняет анимацию процесса минимизации.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","text":"make_plot(u::Matrix, Xₙ::Vector, Tₘ::Vector, m::Int,\n               ϕ_l::Matrix = missings(2), ϕ_r::Matrix = missings(2),\n               f1::Vector = missings(2), f2::Vector = missings(2),\n               analitical = nothing;\n               label::String = \"u\")\n\nРисует m-ый кадр решения u. Xₙ, Tₘ — сетки. ϕ_l, ϕ_r — вырожденные решения. f1, f2 — сгенерированные априорные данные. analitical — или функция или сеточные значения аналитического решения. label::String — LaTeX строка подписи искомой функции с экранирование спец. символов.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.minimize-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Any,Any,Array{T,1} where T,Any,Any,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.minimize","text":"minimize(q₀::Vector, u₀::Vector,\n         ulₘ::Vector, urₘ::Vector,\n         ψ₀::Vector,\n         ψl::Vector, ψr::Vector,\n         Xₙ, N,\n         Tₘ::Vector, M,\n         ε,\n         f1_data::Vector, f2_data::Vector;\n         S::Int = 10,\n         β::Real = 0.01,\n         w::Real = 0.0001,\n         create_mesh::Function = x -> [NaN, NaN])  -> Vector, Vector, Matrix\n\nВернет qˢ на оригинальной сетке Xₙ[:,1].\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination","text":"phidetermination(q::Vector, ub::Vector,\n                 Xₙ::Vector, N::Int,\n                 Tₘ::Vector, M::Int;\n                 reverseX = false)\n\nРешает ОДУ для нахождения вырожденного корня.\n\nreverseX флаг обозначающий обратное направление интегрирования по оси X.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve","text":"solve(y₀::Vector, Xₙ::Vector, N::Int,\n      Tₘ::Vector, M::Int,\n      ε::Real, ulₘ::Vector, urₘ::Vector,\n      qₙ::Vector,\n      RP::Function = directRP,\n      jac::Function = ∂directRP_∂y;\n      α::Complex = complex(0.5, 0.5),\n      create_mesh::Function = x -> [NaN, NaN]) -> Matrix, Matrix, Vector\n\nФункция, которая находит решение прямой задачи с помощью одностадийной схемы Розенброка с комплексным коэффициентом.\n\nArguments\n\ny₀::Vector:         Сеточные значения начального условия.\nXₙ::Vector:         Пространственная сетка по X.\nN::Int:             Число интервалов сетки по X.\nTₘ::Vector:         Пространственная сетка по t.\nM::Int:             Число интервалов сетки по t.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Function:      Сеточные значения левого ГУ.\nurₘ::Function:      Сеточные значения правого ГУ.\nqₙ::Vector:         Сеточные значения \"неоднородности\", см. постановку задачи.\nRP::Function:       Функция вычисления вектора правой части — directRP.\njac::Function:      Якобиан правой части по вектору y — ∂DRP_∂y.\nα::Complex:         Коэффициент схемы. При α = 0 — схема Эйлера, при α = complex(0.5, 0.5) — схема Розенброка с комплексным коэффициентом.\ncreate_mesh::Function: Принимает один аргумент x_tp положение переходного слоя и формирует подходяющую сетку.\n\nReturn\n\nТройку:     - Матрицу размера (N+1 M+1), содержащую значения искомой функции на сетках X_n T_m,.     - Матрицу размера (N+1 M+1), содержащую значения стеки X_n на каждом моменте времени.     - Вектора размера M+1, содержащий координаты положения переходного слоя в каждый момент времени.\n\ninfo: Info\nXₙ, qₙ, y₀     векторы размера N+1!\nTₘ, ulₘ, urₘ   векторы размера M+1!\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","text":"warning: Warning\nМассивы Xₙ, Tₘ, u, f1, f2 Передаются как есть! Они переварачиваются внутри функции локально.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.u_init-Tuple{Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.u_init","text":"u_init(x::Real; ε::Real = 0.2, x_tp = 0.15) -> Real\n\nНачальные условия в виде (x^2 - x -2) -6 tanh( -3 xi), где xi = fracx - x_tpε. x_tp — положение внутрннего переходного слоя.\n\nnote: Note\nГраничные условия для этих начальных условий должны быть заданы как (-8, 4).\n\nnote: Note\nВы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.\n\nExample\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)\n11-element Array{Float64,1}:\n -7.868156688432881\n -5.900893714323723\n  1.650893714323725\n  3.6581566884328813\n  3.753366656356917\n  3.749669571706625\n  3.7599835485135173\n  3.7899991809276505\n  3.839999959220786\n  3.909999997969723\n  3.999999999898918\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.Φ-Tuple{Array{T,2} where T,Array{T,2} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.Φ","text":"Φ(ϕ_l::Matrix, ϕ_r::Matrix, N::Int, M::Int) -> ::Vector\n\nВычисляет полуразность вырожденных решений phi_l^m - phi_r^m2 + phi_l^m на каждом шаге по времени m с помощью матриц вырожденных решений phi_l и phi_r вырожденного корня.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.ARP_y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.ARP_y","text":"\"     ARP_y(y::Vector, m::Int,           Xₙ::Vector, N::Int,           Tₘ::Vector, M::Int,           ε::Real,           ulₘ::Vector, urₘ::Vector,           qₙ::Vector,           Uₙₘ::Matrix, f1::Vector, f2::Vector) ->           (::Vector, ::Vector, ::Vector)\n\nВозращает три диагонали якоибана правой части сопряженной задачи. Входные параметры полностью аналогичны adjointRP.\n\nReturn\n\nВозвращает три вектора dl, d, dl элементов якоибана. Нижняя и верхняя диагонали длины N-2, главная — N-1.\n\n    [ d[1]  du[1]                         ]\n    [ dl[1] d[2]  du[2]                   ]\n    [ 0     dl[2] d[3] du[3]              ]\n    [           ...  ...  ...             ]\n    [                ...  ...     du[N-2] ]\n    [                     dl[N-2] d[N-1]  ]\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y","text":"\"     DRP(y::Int, m::Int,         Xₙ::Vector, N::Int,         ε::Real,         ulₘ::Vector, urₘ::Vector,         qₙ::Vector) -> (::Vector, ::Vector, ::Vector)\n\nВозращает три диагонали якоибана правой части прямой задачи, чтобы после сформировать трехдигональную матрицу Tridiagonal.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\nReturn\n\nВозвращает три вектора dl, d, dl элементов якоибана. Нижняя и верхняя диагонали длины N-2, главная — N-1.\n\n    [ d[1]  du[1]                         ]\n    [ dl[1] d[2]  du[2]                   ]\n    [ 0     dl[2] d[3] du[3]              ]\n    [           ...  ...  ...             ]\n    [                ...  ...     du[N-2] ]\n    [                     dl[N-2] d[N-1]  ]\n\nExample\n\njulia> # Данные необохдимо подготовить, например, как в examples/example_direct.jl\n\njulia> # Подготовим массивы, выбросив граничные точки\n\njulia> # ведь тестируемая функция — для внутреннего использования\n\njulia> qq = qₙ[2:N];\n\njulia> y = y₀[2:N];\n\njulia> dl, d, du = NonLinearReactionAdvectionDiffusionWithFrontData.DRP_y(y, 1, Xₙ, N, ε, ulₘ, urₘ, qq);\n\njulia> Tridiagonal( dl, d, du )\n49×49 Tridiagonal{Float64,Array{Float64,1}}:\n -991.038   305.462      ⋅         ⋅         ⋅         ⋅         ⋅     …       ⋅         ⋅         ⋅         ⋅         ⋅        ⋅\n[...]\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP","text":"adjointRP(y::Vector, m::Int,\n          Xₙ::Vector, N::Int,\n          Tₘ::Vector, M::Int,\n          ε::Real,\n          ulₘ::Vector, urₘ::Vector,\n          qₙ::Vector,\n          Uₙₘ::Matrix, f1::Vector, f2::Vector)\n\nВычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nArguments\n\ny::Vector:          Вектор размера N-1, решение в текущий момент без ГТ.\nm::Int:             Номер шага в сетке по времени.\nXₙ::Vector:         Вектор размера N+1 сетки по X, вместе с ГТ.\nN::Int:             Число интервалов в полной сетке по X.\nTₘ::Vector:         Вектор размера M+1 сетки по T.\nM::Int:             Число интервалов в полной сетке по T.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Vector:        Вектор сеточных значений левого ГУ.\nurₘ::Vector:        Вектор сеточных значений правого ГУ.\nqₙ::Vector:         Вектор размера N-1 сеточные значений  неоднородности без ГТ.\nUₙₘ::Matrix:        Матрица размера N-1, M+1 решения прямой задачи при данном qₙ.\nf1::Vector:         Эспериментальные данные — положение внутреннего слоя, размера M+1.\nf2::Vector:         Эспериментальные данные — значение функции на внутреннеем слое, размера M+1.\nw::Real:            Априорный параметр в аппроксимации дельта-функции (см. heterogeneity, δw).\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.deltaw-Tuple{Int64,Real,Array{T,1} where T,Int64,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.deltaw","text":"deltaw(n::Int, x₀::Real, Xₙ::Vector, N::Int, w::Real)\n\nВычисляет delta(x - x₀), где x = Xₙ[n]. n — номер узла в сетке Xₙ(без граничных точек).\n\nИспользует более точную конечно разностную аппроксимацию дельта функции, w — априорный параметр, см. δw.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.directRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.directRP","text":"directRP(y::Vector, m::Int,\n         Xₙ::Vector, N::Int,\n         ε::Real,\n         ulₘ::Vector, urₘ::Vector,\n         qₙ::Vector)\n\nВычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nArguments\n\ny::Vector:          Вектор размера N-1, решение в текущий момент без ГТ.\nm::Int:             Номер шага в сетке по времени.\nXₙ::Vector:         Вектор размера N+1 сетки по X, вместе с ГТ.\nN::Int:             Число интервалов в полной сетке по X.\nε::Real:            Малый параметр при старшей производной.\nulₘ::Vector:        Вектор сеточных значений левого ГУ.\nurₘ::Vector:        Вектор сеточных значений правого ГУ.\nqₙ::Vector:         Вектор размера N-1 сеточные значений  неоднородности без ГТ.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.dparams-Tuple{}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.dparams","text":"dparams()\n\nВозвращает стандартный набор параметров для равномерной сетки.\n\nReturn\n\n`a, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀ `\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform-Tuple{}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.dparams_nonuniform","text":"dparams_nonuniform()\n\nВозвращает стандартный набор параметров для неравномерной сетки.\n\nReturn\n\nreturn a, b, t₀, T, N, M, ε, Xₙ, Tₘ, qₙ, ulₘ, urₘ, u₀, meshf;\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros-Tuple{Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros","text":"find_f_zeros(f::Vector, Xₙ::Vector)\n\nНаходит такой x, что f(x) = 0. f — сеточные значения функции на сетке Xₙ.\n\nwarning: Warning\nФункция обязана пересекать ноль. Не сработает на неотрицательных функциях.\nВозвращает только аргуент реализующий первый ноль.\nРешение ищется аппроксимацией.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.heterogeneity-Tuple{Int64,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.heterogeneity","text":"heterogeneity(n::Int, m::Int,\n             Xₙ::Vector, N::Int,\n             Tₘ::Vector, M::Int,\n             Uₙₘ::Matrix,\n             f1::Vector, f2::Vector,\n             w::Real)\n\nНеоднородность выражающая невязку текущего решения с искомым. 2 delta( x - f_1(t) ) ( u^s(xt) - f_2(t) ).\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.shishkin_mesh","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.shishkin_mesh","text":"shishkin_mesh(a::Real, b::Real,\n              x_tp::Real, ε::Real,\n              N::Int = 50,\n              C_i::Real = 1.0, K_i::Real = 1.0,\n              C_b::Real = 1.0, K_b::Real = 1.0)\n\nВозвращает кусочнораномерную сетку со сгущением на границах и на переходном слое.\n\nArguments\n\na::Int      Левая граница.\nb::Int      Правая граница.\nx_tp::Real  Положение переходного слоя.\nε::Real     Малый параметр при старшей производной.\nC_i::Real   Масштабирующий коэффициент для ширины внутреннего сгущения.\nK_i::int    Масштабирующий коэффициент количества интервалов внутреннего сгущения.\nC_b::Real   Масштабирующий коэффициент для ширин пограничных сгущений.\nK_b::Int    Масштабирующий коэффициент количеств интервалов пограничных сгущений.\nK::Int      Кол-во интервалов вне всех сгущений.\n\nReturn\n\nКусчноравномерную сетк, на эскизе чтоками изображены узлы сетки.\n\n.....  .  .  .  .  .  .  .  .  .  .......  .  .  .  .  .  .  .  .  .  .  ......\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints-Tuple{Array{T,1} where T,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints","text":"strip_borderPoints(a::Vector, N) -> Vector\n\nФункция для внутренного использования.\n\nВходящий массив должен быть размера N+1. Обрезает граничные точки слева и справа. Возвращает массив размера N-1.\n\nExample\n\njulia> N = 10; a = collect(1:N+1);\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints(a, N)\n9-element Array{Int64,1}:\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.δw-Tuple{Real,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.δw","text":"δw(x::Real, ω::Real) -> Real\n\nЛинейная аппроксимация δ(x), ω — эвристический парамет. Подбирается так, чтобы невязка сопряженной задачи 2 delta( x - f_1(t)) ( u(xt) - f_2(t)) при подстановке в неё u(x,t;q) истинного q обнулялась почти везде, но не всюду.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂ARP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂ARP_∂y","text":"∂ARP_∂y(y::Vector, m::Int,\n      Xₙ::Vector, N::Int,\n      Tₘ::Vector, M::Int,\n      ε::Real,\n      ulₘ::Vector, urₘ::Vector,\n      qₙ::Vector,\n      Uₙₘ::Matrix, f1::Vector, f2::Vector) -> Tridiagonal\n\nОбертка фнукции ARP_y, которая возвращает Tridiagonal( ARP_y(...)) трехдиагональную матрицы из векторов, которые возвращает ARP_y.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y","text":"∂DRP_∂y(y::Vector, m::Int,\n        Xₙ::Vector, N::Int,\n        ε::Real,\n        ulₘ::Vector, urₘ::Vector,\n        qₙ::Vector) -> Tridiagonal\n\nОбертка фнукции DRP_y, которая возвращает Tridiagonal( DRP_y(...)) трехдиагональную матрицу из векторов, которые возвращает DRP_y(...).\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T,Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂adjointRP_∂y","text":"∂adjointRP_∂y(y::Vector, m::Int,\n               Xₙ::Vector, N::Int,\n               Tₘ::Vector, M::Int,\n               ε::Real,\n               ulₘ::Vector, urₘ::Vector,\n               qₙ::Vector,\n               Uₙₘ::Matrix, f1::Vector, f2::Vector,\n               w::Real)\n\nФункция якобиана для adjointRP. Все аргументы, размерности входных векторов такие же, как и у adjointRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve_adjoint.qₙ, y    размера N-1,\nXₙ         размера N+1,\nUₙₘ        размера N-1, M+1\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y","text":"∂directRP_∂y(y::Vector, m::Int,\n              Xₙ::Vector, N::Int,\n              ε::Real,\n              ulₘ::Vector, urₘ::Vector,\n              qₙ::Vector)\n\nФункция якобиана для adjointRP. Размерности входных векторов такие же, как и у directRP.\n\nwarn: Warn\nФункция не входит в публичный API, поэтому размерность входных векторов отличается от аналогичных в solve.qₙ, y размера N-1!\nXₙ размера N+1.\n\n\n\n\n\n","category":"method"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/direct/check/dt_direct.jl\"","category":"page"},{"location":"generated/helpers/doctest_direct/#Непосредственная-реализация-проверки-1","page":"-","title":"Непосредственная реализация проверки","text":"","category":"section"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\n\n# Тест проверяет корректность решения прямой задачи. Алгоритм описан в /docs/src/direct/direct_check.md\n# Возвращает решение, аналитическое решение, сетку по X, сетку по T.\nusing NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing ForwardDiff;\n\n# Зададим параметры для прямой задачи\nu_l(t) = 0;                     # ГУ удовлетворяющие модельной функции\nu_r(t) = 0;                     # ГУ удовлетворяющие модельной функции\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 1;                   # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);              # Сеточные значения коэффициента линейного усиления\nulₘ= u_l.(Tₘ);                  # Сеточные значения левого  ГУ\nurₘ= u_r.(Tₘ);                  # Сеточные значения правого ГУ\n\n\n# Зададим модельную функцию и невязку, получаемую после подстановки `g` в исходное уравнение\nfunction g(x, m)\n    t = Tₘ[m]\n    (1 - 2t)*sin(π*x)\nend\nfunction g_d(x::Real, m::Int)\n    t = Tₘ[m];\n    - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - qf(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x)\nend\n\ny₀ = g.(Xₙ, 1);               # Начальные условия\n# Модельное решение найденное с помощью известного аналитического решения\nu_model = [ g(x, m) for x in Xₙ, m in 1:M+1];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nfunction RP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ)\n    d = [ g_d(x, m) for x in Xₙ[2:N] ]\n    NonLinearReactionAdvectionDiffusionWithFrontData.directRP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) - d\nend\n# Хоть мы и конструируем якобиан с помощью автоматического дифференцирования,\n# примите во внимание, что Якобиан ``f_y`` при добавлении `g_d` останется\n# без изменений, т.к. `g_d` зависит только от ``x,t``.\n# То, что он не зависит от добавления `g_d` мы убедимся через 7 строк.\nj(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) = ForwardDiff.jacobian( z -> RP(z, m, Xₙ, N, ε, ulₘ, urₘ, qₙ), y)\n\n# С использованием автоматического дифференцирования\nu, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, j);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n# С использованием трехдиагонального якобиана без изменений.\nu, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n(u, u_model, Xₙ, Tₘ)\nnothing #hide","category":"page"},{"location":"generated/helpers/doctest_direct/#Визуализация-1","page":"-","title":"Визуализация","text":"","category":"section"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(u, Xₙ, Tₘ, dd, dd, dd, d, d, u_model; name = \"dicrect_check.gif\")","category":"page"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"err = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/helpers/doctest_direct/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/final_adjoint_check/#Проверка-корректности-решения-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"","category":"section"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Подставим найденные производные в исходное уравнение (см.Сопряженная задача) и перенеся все в правую часть, определим g_d.","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"g_d(xt) = 2 sin(pi x) - ( - varepsilon pi^2 (1 - 2t) sin(pi x) )+\nu(xt) pi (1 - 2t) cos(pi x) + q(x) (1 - 2t) sin(pi x) - 2 delta( x - f_1(t) ) (u(xt) - f_2(t))","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"left\nbeginaligned\n     fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 + u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) - g_d quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/adjoint_check.jl\". Файл содержит один @testset, внутри него реализовано решение вышеописанной системы, проверка его корректности через @test. А так же, @testset возвращает ψ, ψ_model, Xₙ, Tₘ, что соответствует решению, аналитическому решению, сетке по X, T.","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/adjoint/check/dt_adjoint.jl\"","category":"page"},{"location":"generated/final_adjoint_check/#Непосредственная-реализация-проверки-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Непосредственная реализация  проверки сопряженной задачи","text":"","category":"section"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\n\n# Юнит тест проверяет корректность решения прямой задачи.\n# Алгоритм описан в /docs/src/direct/adjoint_check.md\n# Возвращает решение, аналитическое решение, сетку по X, сетку по T.\n\nusing NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: heterogeneity, adjointRP, ∂ARP_∂y;\n\nusing ForwardDiff;\n\n# Сначала, сгенирируем экспериментальные данные, на увеличенном числе узлов.\nu_l(t) = -8\nu_r(t) =  4\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной\n                                # задаче необходимо определить, но при генерации априорной\n                                # информации мы задаем некоторый коэффициент, который,\n                                # собственно, после имея априорную информацию и будем определять.\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0.0, 0.28;              # Область по T\nN, M = 250, 500;                # Увеличенное Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);              # Сеточные значения коэффициента линейного усиления\nulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ\nurₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ\nu₀ = u_init.(Xₙ);               # Начальные условия\n#\nu, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);\n\n# Генерация априорной информации\nϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                  # Левый вырожденный корень\nϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true); # Правый вырожденный корень\nϕ       = Φ(ϕl, ϕr, N, M);                                          # Серединный корень\nf1_data = f1(ϕ, u, Xₙ, N, M);                                       # Положение переходного слоя\nf2_data = f2(f1_data, u, Xₙ, N, M);                                 # Значение функции на переходном слое\n\n# Решение сопряженной задачи\n\n\n# Теперь переходим непосредственно к проверке\n# Модельная функция\nraw\"\"\"\n    g(n::Int, X = Xₙ, N::Int,\n        m::Int, T = Tₘ, M::Int) -> Real\n\nМодельная функция ``(1-2t)\\sin(\\pi x)``.\n`n` — номер узла в сетке по X. `m` — номер шага в сетке по T.\n`X` — сетка по X, `N` — кол-во **интервалов** сетки.\n`Tₘ` — сетка по T, `M` — кол-во **интервалов** сетки.\nЗахватывает переменную `T` конечное время моделирования из окружения.\n\"\"\"\nfunction g(n::Int, X, N::Int,\n            m::Int, Tₘ, M::Int)\n    t = Tₘ[m]\n    x = X[n]\n    return (1 - 2t/T)*sin(π*x)\nend\n\n# Выберем априорный параметр аппроксимации дельта-функции\nω = 0.0001;\nraw\"\"\"\n    g_d(n::Int, Xₙ::Vector, N::Int,\n        m::Int, Tₘ::Vector, M::Int,\n        ε::Real, qₙ::Vector,\n        u::Matrix, f1::Vector, f2::Vector) -> Real\n\nВычисляет невязку, т.е. рез ультат подстановки ``g`` в постановку сопряженной задачи.\n`n` — номер узла в сетке по X. `m` — номер шага в сетке по T.\n`X` — сетка по X, `N` — кол-во **интервалов** сетки.\n`Tₘ` — сетка по T, `M` — кол-во **интервалов** сетки.\n\"\"\"\nfunction g_d(n::Int, Xₙ::Vector, N::Int,\n                m::Int, Tₘ::Vector, M::Int,\n                ε::Real, qₙ::Vector,\n                u::Matrix, f1::Vector, f2::Vector,\n               w::Real)\n    x = Xₙ[n];\n    t = Tₘ[m];\n    out  = 2/T * sin(π * x) - ( - ε * π^2 * (1 - 2t/T) * sin(π * x)) + π * (1 - 2t/T) * cos(π * x) * u[n,m] + qₙ[n] * (1 - 2t/T) * sin(π * x) - heterogeneity(n, m, Xₙ[2:N], N, Tₘ, M, u, f1, f2, w)\n    return out;\nend\n\nUₙₘ = u;                                        # Сохраним матрицу решения прямой задачи\nψl = [0.0 for i in 1:M+1];                      # Левые  ГУ для модельной функции\nψr = [0.0 for i in 1:M+1];                      # Правые ГУ для модельной функции\nψ₀ = [g(n, Xₙ, N, M+1, Tₘ, M) for n in 1:N+1];  # Начальные условия для модельной функции\n# Внимание! сопряженная задача — ретроспективная\n# ``u₀ = g(x, T)``\n# Модельное решение найденное с помощью известного аналитического решения\n# Для его генерации используем инвертированную сетку по времени, чтобы\n# массив `ψ_model` и `ψ` имели одно и тоже направление хода времени.\nψ_model = [ g(n, Xₙ, N, m, Tₘ, M) for n in 1:N+1, m in M+1:-1:1];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nraw\"\"\"\n    RP(y, m, Xₙ, N, Tₘ, M, ε, qₙ, u, f1, f2) -> Vector\n\n# Return\n    Вектор размера `N-1`, сеточные значения правой части уравнения,\n    для которого `g(x,t)` будет являться решением.\n\n!!! warning\n    Функция не предназначена для самостоятельного использования,\n    она передается в качестве аргумента в `solve`, внутри которой\n    для нее сформуются аргументы нужной длины, для которых не\n    потребуется смещений индексов.\n\"\"\"\nfunction RP(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, u, f1, f2, w)\n    arp = adjointRP(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, u, f1, f2, w)\n    d = [ g_d(n, Xₙ, N, m, Tₘ, M, ε, qₙ, u, f1, f2, w) for n in 1:N-1]\n    return arp .- d\nend\n# Якобиан сконструируем тем же способом, что и внутри пакета в `src/adjoint.jl`.\nj(y, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, U, f1, f2, w) = ForwardDiff.jacobian( z -> adjointRP(z, m, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, U, f1, f2, w), y)\n\n# С использованием автоматического дифференцирования\nψ = solve_adjoint(ψ₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, RP, j, w = ω)\n@test all(isapprox.(ψ_model, ψ, atol = 0.025))\n\n# С использованием трехдиагонального якобиана\nψ = solve_adjoint(ψ₀, Xₙ, N, Tₘ, M, ε, ψl, ψr, qₙ, Uₙₘ, f1_data, f2_data, RP, ∂ARP_∂y, w = ω)\n@test all(isapprox.(ψ_model, ψ, atol = 0.025))\n\n(ψ, ψ_model, Xₙ, Tₘ)\nnothing #hide","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(ψ, Xₙ, Tₘ, dd, dd, dd, d, d, ψ_model; name = \"direct_check.gif\")","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"err = ψ .- ψ_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"","category":"page"},{"location":"generated/final_adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"This page was generated using Literate.jl.","category":"page"},{"location":"adjoint/check/adjoint_check/#Проверка-корректности-решения-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"","category":"section"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Подставим найденные производные в исходное уравнение (см.Сопряженная задача) и перенеся все в правую часть, определим g_d.","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"g_d(xt) = 2 sin(pi x) - ( - varepsilon pi^2 (1 - 2t) sin(pi x) )+\nu(xt) pi (1 - 2t) cos(pi x) + q(x) (1 - 2t) sin(pi x) - 2 delta( x - f_1(t) ) (u(xt) - f_2(t))","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"left\nbeginaligned\n     fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 + u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) - g_d quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/check/adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/adjoint_check.jl\". Файл содержит один @testset, внутри него реализовано решение вышеописанной системы, проверка его корректности через @test. А так же, @testset возвращает ψ, ψ_model, Xₙ, Tₘ, что соответствует решению, аналитическому решению, сетке по X, T.","category":"page"},{"location":"direct/check/direct_check/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Применим метод пробной функции или контрольной невязки. Это позволит сравнивать решение, получаемое нашей схемой, с аналитическим решением, даже если мы не можем найти аналитическое решение исходного уравнения.","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Идея проверки заключается в выборе некоторой известной пробной функции, например, g(xt), которая не является решением исходного уравнения. Подставив пробную функцию уравнение, оно не обращается в тождество. Если преобразовать уравнение путем вычитания невязки, полученной в прошлом действии, то мы получим новое уравнение, для которого уже g(xt) –- решение.","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"После этого, мы решаем решаем модифицированное уравнение с помощью нашей схемы, в которой нужно лишь подправить функцию возвращающую вектор правой части –- нужно дополнительно вычесть невязку, формулу для которой мы нашли аналитически.","category":"page"},{"location":"direct/check/direct_check/#Алгоритм-1","page":"Проверка корректности решения прямой задачи","title":"Алгоритм","text":"","category":"section"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим следующую пробную функцию g(xt) = (1-2t) sin(pi x). Найдем её производные:","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Подстановка пробной функции в исходной уравнение (см. Постановка прямой задачи), позволит нам определить g_d","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 -\n    fracpartial upartial t = -u fracpartial upartial x +\n    q(x)u - g_d(xt) quad x in (01) quad t in (0T \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T \n    u(xt) = u_init(x) qquad x in 01 t = 0\nendaligned\nright","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Так как мы хотим тестировать наш алгоритм решения прямой задачи, то, очевидно, мы будет применять тот же метод и те же функции. Модификация схемы Розенброка будет заключаться в добавлении соответствующего слагаемого в вектор правой части. Это слагаемое не содержит y_i, значит его добавление никак не повлияет на якобиан.","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Так, аргументами функции solve, кроме параметров определяющих саму начально-краевую задачу, будут функции модифицированной правой части и старой функции якобиана. Во втором тесте кроме модифицированной правой части RP на вход подается якобиан полученный автоматическим дифференцированием, чтобы отловить ошибки в формулах якобиана.","category":"page"},{"location":"direct/check/direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Такая проверка корректности решения применяется в unit тесте \"tests/direct_check.jl\". Здесь мы сделаем include, а Literate.jl включит текст теста вместе с результатами его выполнения  в этот md файл ( см. make.jl, строго говоря, конкретно здесь, мы компануем этот файл и содержимое файла, который сгенерирует Litarate.jl из `dtdirect.jlвdocs/src/generated/directcheck.jl` ).","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"DocTestSetup = quote\n    using NonLinearReactionAdvectionDiffusionWithFrontData\n    using Plots\nend","category":"page"},{"location":"#Главная-1","page":"Главная","title":"Главная","text":"","category":"section"},{"location":"#Постановка-задачи-1","page":"Главная","title":"Постановка задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Рассмотрим прямую задачу для сингулярно возмущенного уравнения типа Бюргерса:","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 -\n    fracpartial upartial t = -u fracpartial upartial x +\n    q(x)u quad x in (01) quad t in (0T \n    u(0t) = u_l(t) quad u(1t) = u_r(t) quad t in (0T \n    u(xt) = u_i(x) qquad x in 01 t=0\nendaligned\nright","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Решение этой задачи имеет движущийся слой, положение которого во времени описывает x = x_tp(t).","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Обратная задача состоит в определении коэффициента линейного усиления q(x), x in 01, по известной дополнительной информации о положении переходного слоя и значения функции на переходном слое:","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"x_tp = f_1(t) qquad u(x_tp(t)t) = f_2(t) qquad t in 0 T","category":"page"},{"location":"#Содержание-1","page":"Главная","title":"Содержание","text":"","category":"section"},{"location":"#Прямая-задача-1","page":"Главная","title":"Прямая задача","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Pages = [\n    \"direct/direct.md\",\n    \"direct/experimental_data.md\",\n    \"generated/docexample_direct.md\",\n    \"generated/final_direct_check.md\",\n]\nDepth = 1","category":"page"},{"location":"#Сопряженная-задача-1","page":"Главная","title":"Сопряженная задача","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Pages = [\n    \"adjoint/adjoint.md\",\n    \"generated/final_adjoint_check.md\",\n    \"generated/docexample_adjoint.md\",\n]\nDepth = 1","category":"page"},{"location":"#Обратная-задача-1","page":"Главная","title":"Обратная задача","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Pages = [\n    \"functional/functional.md\",\n    \"functional/numerical_expirements.md\",\n]\nDepth = 1","category":"page"},{"location":"#Локальная-документация-1","page":"Главная","title":"Локальная документация","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Документация на gh-pages может не содержать анимированных решений в форматах gif и mp4 или содержать их урезанную по FPS версию.","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Вы можете сгенерировать документацию локально:","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"git clone\nhttps://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl\ncd NonLinearReactionAdvectionDiffusionWithFrontData.jl\njulia --color=yes -e \"Pkg.build(verbose=true);\"\njulia --color=yes -e \"Pkg.test\"\ncd docs\njulia --color=yes make.jl\npython3 -m http.server --bind localhost > /dev/null 2>&1 &","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"После, откройте http://localhost:8000/build/ в своем браузере (точный адрес может зависеть от $(pwd) в которой вы запустили сервер).","category":"page"},{"location":"generated/final_direct_check/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Применим метод пробной функции или контрольной невязки. Это позволит сравнивать решение, получаемое нашей схемой, с аналитическим решением, даже если мы не можем найти аналитическое решение исходного уравнения.","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Идея проверки заключается в выборе некоторой известной пробной функции, например, g(xt), которая не является решением исходного уравнения. Подставив пробную функцию уравнение, оно не обращается в тождество. Если преобразовать уравнение путем вычитания невязки, полученной в прошлом действии, то мы получим новое уравнение, для которого уже g(xt) –- решение.","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"После этого, мы решаем решаем модифицированное уравнение с помощью нашей схемы, в которой нужно лишь подправить функцию возвращающую вектор правой части –- нужно дополнительно вычесть невязку, формулу для которой мы нашли аналитически.","category":"page"},{"location":"generated/final_direct_check/#Алгоритм-1","page":"Проверка корректности решения прямой задачи","title":"Алгоритм","text":"","category":"section"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Зададим следующую пробную функцию g(xt) = (1-2t) sin(pi x). Найдем её производные:","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Подстановка пробной функции в исходной уравнение (см. Постановка прямой задачи), позволит нам определить g_d","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 -\n    fracpartial upartial t = -u fracpartial upartial x +\n    q(x)u - g_d(xt) quad x in (01) quad t in (0T \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T \n    u(xt) = u_init(x) qquad x in 01 t = 0\nendaligned\nright","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Так как мы хотим тестировать наш алгоритм решения прямой задачи, то, очевидно, мы будет применять тот же метод и те же функции. Модификация схемы Розенброка будет заключаться в добавлении соответствующего слагаемого в вектор правой части. Это слагаемое не содержит y_i, значит его добавление никак не повлияет на якобиан.","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Так, аргументами функции solve, кроме параметров определяющих саму начально-краевую задачу, будут функции модифицированной правой части и старой функции якобиана. Во втором тесте кроме модифицированной правой части RP на вход подается якобиан полученный автоматическим дифференцированием, чтобы отловить ошибки в формулах якобиана.","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Такая проверка корректности решения применяется в unit тесте \"tests/direct_check.jl\". Здесь мы сделаем include, а Literate.jl включит текст теста вместе с результатами его выполнения  в этот md файл ( см. make.jl, строго говоря, конкретно здесь, мы компануем этот файл и содержимое файла, который сгенерирует Litarate.jl из `dtdirect.jlвdocs/src/generated/directcheck.jl` ).","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"EditURL = \"https://github.com/aborzunov/NonLinearReactionAdvectionDiffusionWithFrontData.jl/blob/master/docs/src/direct/check/dt_direct.jl\"","category":"page"},{"location":"generated/final_direct_check/#Непосредственная-реализация-проверки-1","page":"Проверка корректности решения прямой задачи","title":"Непосредственная реализация проверки","text":"","category":"section"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"using Test;\nusing LaTeXStrings;\nusing Plots;\n\n# Тест проверяет корректность решения прямой задачи. Алгоритм описан в /docs/src/direct/direct_check.md\n# Возвращает решение, аналитическое решение, сетку по X, сетку по T.\nusing NonLinearReactionAdvectionDiffusionWithFrontData;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: phidetermination, Φ;\nusing NonLinearReactionAdvectionDiffusionWithFrontData: f1, f2;\nusing ForwardDiff;\n\n# Зададим параметры для прямой задачи\nu_l(t) = 0;                     # ГУ удовлетворяющие модельной функции\nu_r(t) = 0;                     # ГУ удовлетворяющие модельной функции\nqf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления\nε = 0.2;                        # Малый параметр при старшей производной\na, b = 0, 1;                    # Область по X\nt₀, T = 0, 1;                   # Область по T\nN, M = 50, 80;                  # Кол-во разбиений по X, T\nh = (b-a)/N;                    # шаг по X\nτ = (T-t₀)/M;                   # шаг по T\nXₙ = [a  + n*h for n in 0:N];   # Сетка по Х\nTₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т\nqₙ =      qf.(Xₙ);              # Сеточные значения коэффициента линейного усиления\nulₘ= u_l.(Tₘ);                  # Сеточные значения левого  ГУ\nurₘ= u_r.(Tₘ);                  # Сеточные значения правого ГУ\n\n\n# Зададим модельную функцию и невязку, получаемую после подстановки `g` в исходное уравнение\nfunction g(x, m)\n    t = Tₘ[m]\n    (1 - 2t)*sin(π*x)\nend\nfunction g_d(x::Real, m::Int)\n    t = Tₘ[m];\n    - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - qf(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x)\nend\n\ny₀ = g.(Xₙ, 1);               # Начальные условия\n# Модельное решение найденное с помощью известного аналитического решения\nu_model = [ g(x, m) for x in Xₙ, m in 1:M+1];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nfunction RP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ)\n    d = [ g_d(x, m) for x in Xₙ[2:N] ]\n    NonLinearReactionAdvectionDiffusionWithFrontData.directRP(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) - d\nend\n# Хоть мы и конструируем якобиан с помощью автоматического дифференцирования,\n# примите во внимание, что Якобиан ``f_y`` при добавлении `g_d` останется\n# без изменений, т.к. `g_d` зависит только от ``x,t``.\n# То, что он не зависит от добавления `g_d` мы убедимся через 7 строк.\nj(y, m, Xₙ, N, ε, ulₘ, urₘ, qₙ) = ForwardDiff.jacobian( z -> RP(z, m, Xₙ, N, ε, ulₘ, urₘ, qₙ), y)\n\n# С использованием автоматического дифференцирования\nu, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, j);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n# С использованием трехдиагонального якобиана без изменений.\nu, XX, TP = solve(y₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ, RP, NonLinearReactionAdvectionDiffusionWithFrontData.∂DRP_∂y);\n@test all(isapprox.(u_model, u, atol = 0.01))\n\n(u, u_model, Xₙ, Tₘ)\nnothing #hide","category":"page"},{"location":"generated/final_direct_check/#Визуализация-1","page":"Проверка корректности решения прямой задачи","title":"Визуализация","text":"","category":"section"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Посмотрим на результат решения в сравнении с аналитическим решением","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"d = [missing, missing];\ndd = [missing missing; missing missing];\nmake_gif(u, Xₙ, Tₘ, dd, dd, dd, d, d, u_model; name = \"dicrect_check.gif\")","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"Найдем абсолютную погрешность численного решения","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"err = u .- u_model\nheatmap(Xₙ, Tₘ, err', xlabel=L\"X_n\", ylabel=L\"T_m\", title=\"Absolute Error\", size=(1200, 800))","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"","category":"page"},{"location":"generated/final_direct_check/#","page":"Проверка корректности решения прямой задачи","title":"Проверка корректности решения прямой задачи","text":"This page was generated using Literate.jl.","category":"page"}]
}
