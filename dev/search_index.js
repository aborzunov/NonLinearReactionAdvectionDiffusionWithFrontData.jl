var documenterSearchIndex = {"docs":
[{"location":"adjoint/#Сопряженная-задача-1","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"section"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача формулируется следующим образом:","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 psipartial x^2 + fracpartial psipartial t = u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Перепишем её в удобном виде для применений метода жесткий прямых","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 +  u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Дальше будем использовать уже введенную в решении прямой задачи сетку, x_n in X_n, psi_n equiv psi_n(t) equiv psi(x_n t), u_n equiv u_n(t) equiv u(x_n t), q_n equiv q(x_n). Произведем аппроксимацию частных производных fracpartial partial x, fracpartial^2 partial x^2 по x с помощью конечных разностей.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_npartial t = - varepsilon frac psi_n+1 - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline1 N-1 quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi_n(T) = 0 quad x in 0 1\nendaligned\nright","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сведем дифференциально-алгебраическую систему к дифференциальной, путем подстановки нулевых граничных условий.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    fracpartial psi_1     partial t = - varepsilon frac psi_2     - 2 psi_1              h^2 +  u_1 fracpsi_2 2h + q_npsi_1  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t))  quad t in (0T) \n    fracpartial psi_n     partial t = - varepsilon frac psi_n+1   - 2 psi_n + psi_n-1 h^2 +  u_n fracpsi_n+1 - psi_n-12h + q_npsi_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2 quad t in (0T) \n    fracpartial psi_N-1 partial t = - varepsilon frac          -2 psi_N-1 + psi_N-2  h^2 +  u_N-1 frac - psi_N-22h + q_N-1psi_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t))  quad t in (0T) \n    psi_n(T) = 0 quad n = overline0 N\nendaligned\nright","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Введем","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"вектор столбец искомой функции размерностью N-1: mathbfy = (psi_1 psi_2 dots psi_N-1)^T.\nвектор столбец начальных значений размерностью N-1: mathbfy_i = (0 0 dots 0)^T.\nвектор столбец mathbfARP(mathbfy t) который будет представлять правую часть вышеприведенной системы.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nЗамечание, о технической реализации в коде adjointRP.u, Xₙ передаются как есть, вместе с граничными точками! Внутри функции они локально модифицируются, для сохранения индексации.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1 = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1 fracy_2 2h + q_1y_1  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t))\n    ARP_n = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1(t))(u_n(t) - f_2(t)) quad n = overline2 N-2\n    ARP_N-1 = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1 frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1(t))(u_N-1(t) - f_2(t)) \nendaligned","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"warning: Warning\nСетку нужно развернуть, в тексте об этом дописать.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Используя уже введенную временную сетку по времени t_m in T_m, ARP_n^m equiv ARP_n(t_m) equiv ARP(x_n t_m).","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"beginaligned\n    ARP_1^m = - varepsilon frac y_2 - 2 y_1 h^2 +  u_1^m fracy_2 2h + q_ny_1  -\n     qquad  - 2delta(x_1 - f_1^m)(u_1^m - f_2^m)\n    ARP_n^m = - varepsilon frac y_n+1 - 2 y_n + y_n-1 h^2 +  u_n^m fracy_n+1 - y_n-12h + q_ny_n  -\n     qquad  - 2delta(x_n - f_1^m)(u_n^m - f_2^m) quad n = overline2 N-2\n    ARP_N-1^m = - varepsilon frac  2 y_N-1 + y_N-2 h^2 +  u_N-1^m frac - y_N-22h + q_N-1y_N-1  -\n     qquad  - 2delta(x_N-1 - f_1^m)(u_N-1^m - f_2^m) \nendaligned","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Теперь, систему ОДУ можно записать следующим образом:","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbfARP  (mathbftextbfyt) quad t in t_0T)\n        mathbftextbfy(T) = mathbftextbfy_init\n    endaligned\n    right","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"note: Note\nПравая часть в уравнении для mathbfW в явном виде не зависит от t, а все сеточные функции u, f_1, f_2 берутся в момент времени t_m, вместо frac t_m+1 + t_m2.","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Найдем решение сопряженной задачи следующим образом:","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfW \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbfARP_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfW = \n        qquadqquadqquadqquadquad = mathbftextbfARP  Big(mathbftextbfy(t_m) t_mBig)\n    endaligned","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"(Image: )","category":"page"},{"location":"apriordata/#Нахождение-вырожденных-корней-1","page":"Генерирование априорной информации","title":"Нахождение вырожденных корней","text":"","category":"section"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Левое вырожденное решение","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^ldx = q(x) quad x in (0 1 \n     phi^l(0) = u_l\nendaligned\nright","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Правое вырожденное решение","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^rdx = q(x) quad x in 0 1) \n     phi^r(1) = u_r\nendaligned\nright","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Пересечение функции Phi(x) = abs(phi^l - phi^r)2 + phi^l с функцией u(x t) и будет определять положение переходного слоя x_tp = f1(t) и значение функции u(x_tp(t)t) = f2(t) в этой точке.","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Для поиска положения переходного слоя x_tp в момент времени t0 найдем x при котором Phi(x) - u(x t0) = 0.","category":"page"},{"location":"functional/#Вычисление-функционала-1","page":"Функционал и его градиент","title":"Вычисление функционала","text":"","category":"section"},{"location":"functional/#","page":"Функционал и его градиент","title":"Функционал и его градиент","text":"Jq = intlimits^T_0 left( u(f_1(t) t q) - f_2(t) right)^2 dt + alpha intlimits_0^1 left( q(x) right)^2 dx","category":"page"},{"location":"functional/#","page":"Функционал и его градиент","title":"Функционал и его градиент","text":"где f_1 f_2 — априорная информация, которая была единожды вычислена до итерационного процесса, при известном q(x), alpha — параметр регуляризации, пока равный нулю.","category":"page"},{"location":"functional/#","page":"Функционал и его градиент","title":"Функционал и его градиент","text":"После вычисления сеточных значения u(xt q^s) на сетках Xₙ Tₘ нам необходимо найти значение искомой функции на переходном слое u( f_1(t) t q).","category":"page"},{"location":"functional/#Вычисление-градиента-функционала-1","page":"Функционал и его градиент","title":"Вычисление градиента функционала","text":"","category":"section"},{"location":"functional/#","page":"Функционал и его градиент","title":"Функционал и его градиент","text":"Jq^s(x) = intlimits_0^T u^(s) (xt) psi^(s)(xt) dt","category":"page"},{"location":"direct/#Решение-прямой-задачи-1","page":"Прямая заадча","title":"Решение прямой задачи","text":"","category":"section"},{"location":"direct/#","page":"Прямая заадча","title":"Прямая заадча","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing Plots\n\n# Зададим параметры для прямой задачи\nu_l(t) = -8#*cos(2*π * t);\nu_r(t) = 4# * (1 + sin(2*π * t));\nε = 0.2;\na, b = 0, 1; # Область по Х\nt₀, T = 0, 0.28;\nN, M = 40, 80;\nh = (b-a)/N;\nτ = (T-t₀)/M;\nXₙ = [a  + n*h for n in 0:N];\nTₘ = [t₀ + m*τ for m in 0:M];\nq(x) = 4*sin(3 * π * x);\nu = zeros(M+1, N+1);\n\n# Начальные условия\ny = u_init.( Xₙ[n] for n in 2:N );\n# Некоторая функция q, т.к. мы моделируем априорные данные f1, f2,\n# то она нам известна\nqₙ = [ q(x) for x in Xₙ[2:N] ];\nu = solve!(y, Xₙ, Tₘ, N, M, ε, u_l, u_r, qₙ);\nnothing #hide","category":"page"},{"location":"direct/#Генерирование-априорной-информации-1","page":"Прямая заадча","title":"Генерирование априорной информации","text":"","category":"section"},{"location":"direct/#","page":"Прямая заадча","title":"Прямая заадча","text":"# Вырожденные корни\nqn = [q(x) for x in Xₙ]\nq_low = NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination(qn, y, u_l(0), Xₙ, N::Int);\nq_top = NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination(qn, y, u_r(0), Xₙ[end:-1:1], N::Int);\nq_top = q_top[end:-1:1];\n# Полуразность вырожденных корней\nϕ = NonLinearReactionAdvectionDiffusionWithFrontData.Φ(q_low, q_top, N);\n# Положение переходного слоя\nf1 = NonLinearReactionAdvectionDiffusionWithFrontData.f1(ϕ, u, Xₙ, N, M);\n# Значение функции на переходном слое\nf2 = NonLinearReactionAdvectionDiffusionWithFrontData.f2(f1, u, Xₙ, N, M);\nnothing #hide","category":"page"},{"location":"direct/#График-и-анимация-решения-1","page":"Прямая заадча","title":"График и анимация решения","text":"","category":"section"},{"location":"direct/#","page":"Прямая заадча","title":"Прямая заадча","text":"make_plot(u, Xₙ, Tₘ, 50, q_low, q_top, f1, f2)","category":"page"},{"location":"direct/#","page":"Прямая заадча","title":"Прямая заадча","text":"make_gif(u, Xₙ, Tₘ, q_low, q_top, f1, f2; frame_skip = div(M,50), frames_to_write=80, convert2mp4 = true)\nnothing #hide","category":"page"},{"location":"direct/#","page":"Прямая заадча","title":"Прямая заадча","text":"(Image: )","category":"page"},{"location":"direct_check/#Тестирование-1","page":"Проверка на модельном решении","title":"Тестирование","text":"","category":"section"},{"location":"direct_check/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка на модельном решении","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Подставим найденные производные в исходное уравнение (см.Постановка задачи), таким образом определив g_d (от англ. discrepancy).","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u + g_d(xt) quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Найдем решение следующим образом:","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1 \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n        qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big) + g_d(mathbfX_nfract_m + 1 + t_m2)\n    endaligned","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"где g_d(mathbfX_n) — значения g_d на сетке x_1 x_x ldots x_N, т.е. на сетке mathbfX_n без граничных точек.","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/direct_with_model.jl\".","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"using Test, ForwardDiff\nusing NonLinearReactionAdvectionDiffusionWithFrontData\n\nu_l(t) = 0\nu_r(t) = 0\nε = 0.1;\na, b = 0, 1;\nt₀, T = 0, 1;\nN, M = 40, 80;\nh = (b-a)/N;\nτ = (T-t₀)/M;\nXₙ = [a  + n*h for n in 0:N];\nTₘ = [t₀ + m*τ for m in 0:M];\nq(x) = sin(3 * π * x);\nu = zeros(M+1, N+1);\n\n# Зададим модельную функцию и невязку, получаемую после подстановки `g` в исходное уравнение\ng(x, t) = (1 - 2t)*sin(π*x);\ng_d(x,t) =  - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - q(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x);\n\ny = g.( (Xₙ[n] for n in 2:N), 0 );\nqₙ = [ q(x) for x in Xₙ[2:N] ];\n\n# Модельное решение найденное с помощью известного аналитического решения\nmodel = [ g(x,t) for x in Xₙ, t in Tₘ];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nRP(y, t, Xₙ, N, ε, u_l, u_r, qₙ) = f(y, t, Xₙ, N, ε, u_l, u_r, qₙ) - g_d.(Xₙ[2:N], t)\n# Хоть мы и конструируем якобиан с помощью автоматического дифференцирования, примите во внимание, что\n# Якобиан ``f_y`` при добавлении `g_d` останется без изменений, т.к. `g_d` зависит только от ``x,t``.\n# То, что он не зависит от добавления `g_d` можно убедиться изменением порядка этих двух строк, ну а так же на бумаге.\nj(y, t, Xₙ, N, ε, u_l, u_r, qₙ) = ForwardDiff.jacobian( z -> RP(z, t, Xₙ, N, ε, u_l, u_r, qₙ), y)\n\nu= solve!(y, Xₙ, Tₘ, N, M, ε, u_l, u_r, qₙ, RP, j);\n@test isapprox(model, u, rtol = 1E-3)","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Сохраним анимацию решения на модельной функции.","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"d = [missing, missing]\nmake_gif(u, Xₙ, Tₘ, d, d, d, d, g; frame_skip = div(M,30), frames_to_write=80, name=\"solution_model.gif\")\nnothing #hide","category":"page"},{"location":"direct_check/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"(Image: )","category":"page"},{"location":"adjoint_check/#Проверка-решения-сопряженной-задачи-1","page":"Проверка корректности решения сопряженной задачи","title":"Проверка решения сопряженной задачи","text":"","category":"section"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Подставим найденные производные в исходное уравнение (см.Сопряженная задача) и перенеся все в правую часть, определим g_d.","category":"page"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"g_d(xt) = 2 sin(pi x) - ( - varepsilon pi^2 (1 - 2t) sin(pi x) )+\nu(xt) pi (1 - 2t) cos(pi x) + q(x) (1 - 2t) sin(pi x) - 2 delta( x - f_1(t) ) (u(xt) - f_2(t))","category":"page"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"adjoint_check/#","page":"Проверка корректности решения сопряженной задачи","title":"Проверка корректности решения сопряженной задачи","text":"left\nbeginaligned\n     fracpartial psipartial t = - varepsilonfracpartial^2 psipartial x^2 + u fracpartial psipartial x + q(x)psi  -\n     qquad  - 2delta(x - f_1(t))(u(xt) - f_2(t)) - g_d quad x in (01) quad t in (0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in (0T) \n    psi(xT) = 0 qquad x in 01\nendaligned\nright","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"DocTestSetup = quote\n    using NonLinearReactionAdvectionDiffusionWithFrontData\n    using Plots\nend\n","category":"page"},{"location":"#Главная-1","page":"Главная","title":"Главная","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"","category":"page"},{"location":"#Постановка-задачи-1","page":"Главная","title":"Постановка задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"reference/#Справочник-1","page":"Справочник","title":"Справочник","text":"","category":"section"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]","category":"page"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J","text":"J(uˢ::Matrix, Xₙ::Vector, N::Int,\n       Tₘ::Vector, M::Int,\n       f1::Vector, f2::Vector,\n       qₙˢ::Vector, α::Real = 0.0) -> Real\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.J_q-Tuple{Array{T,2} where T,Array{T,2} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.J_q","text":"J_q(uˢ::Matrix, ψˢ::Matrix,\n         Xₙ::Vector, N::Int,\n         Tₘ::Vector, M::Int) -> Vector\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP-Tuple{Any,Int64,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.adjointRP","text":"function adjointRP(y, m::Int, t, Xₙ, N, Tₘ, M, ε, qₙ, u, f1, f2)\n\nnote: Note\nu, Xₙ передаются как есть, вместе с граничными точками, внутри функции они локально модифицируются, для сохранения индексации\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.delta","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.delta","text":"delta(x, Xₙ, x₀ = 0) -> ::Real\n\nВычисляет конечно разностную аппроксимацию дельта функции delta(x x₀) на сетке Xₙ исходя из intlimits_a^b delta(x x₀) dx = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.directRP-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.directRP","text":"f(y::Vector, 1}, t::Real, Xₙ::Vector, 1},\n  N::Int, ε::Real, u_l::Function, u_r::Function, qₙ::Vector) -> ::Vector\n\nФункция вычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nЕсли записать систему в следующем виде:\n\n    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbff  (mathbftextbfyt) quad t in (t_0T\n        mathbftextbfy(t_0) = mathbftextbfy_init\n    endaligned\n    right\n\nгде\n\n    beginaligned\n        mathbftextbfy = big(u_1  u_2   ldots  u_N - 1 big)^T \n        mathbftextbff = big(f_1  f_2  ldots  f_N - 1big)^T \n        mathbftextbfy_init = big(u_init (x_1)  u_init (x_2)  ldots  u_init (x_N - 1) big)^T\n    endaligned\n\nu_init(x_n)\n\nвычисляется с помощью u_init(x).\n\nТо текущая функция определяет вектор-функцию mathbftextbff следующим образом:\n\n    beginaligned\n        f_1 =       varepsilon dfracy_2        - 2y_1       + u_left(t)h^2 + y_1       dfracy_2        - u_left(t)2h - q(x_1) y_1 \n        f_n =       varepsilon dfracy_n + 1    - 2y_n       + y_n - 1h^2   + y_n       dfracy_n + 1    - y_n - 12h   - q(x_n) u_n quad n=overline2 N-2 \n        f_N - 1 = varepsilon dfracu_right(t) - 2y_N - 1 + y_N - 2h^2   + y_N - 1 dfracu_right(t) - y_N - 22h   - q(x_N-1) y_N-1\n    endaligned\n\nTODO: fix docs\n\nArguments\n\ny::Array{<:Real, 1}:  Вектор размера N-1 решения системы в текущий момент времени\nt::Real:  Текущий момент времени.\nXₙ::Array{<:Real, 1}: Пространственная сетка по x.\nN::Int: Число -интервалов- сеткию\nε::Real: Малый параметр при старшей производной.\nulₙ::Function: Функция левого ГУ.\nurₙ::Function: Функция правого ГУ.\nq::Vector: Вектор размера N-1 представляющий \"неоднородность\", см. постановку задачи.\n\nwarning: Warning\nВсе вектора передаются вместе с граничными точками.Длина должна равняться N+1.\n\nnote: Note\nФункция работает по формулам для равномерной сетки!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","text":"make_gif(u::Matrix, Xₙ::Vector, Tₘ::Vector,\n              ϕ_l::Vector = missings(2), ϕ_r::Vector = missings(2),\n              f1::Vector = missings(2), f2::Vector = missings(2),\n              analitical = nothing;\n              frames_to_write::Int = -1, frame_skip::Int=-1,\n              name = \"solution.gif\", convert2mp4 = false)\n\nРисует gif анимацию решения каждый frame_skip кадр, вплоть по frames_to_write-ый кадр, сохраняет как \"results/name\".\n\nТак же рисует аналитическое решение analitic(x,t), если таково передано.\n\nTODO: Fix doc\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_plot","text":"make_plot(u::Matrix, Xₙ::Vector, Tₘ::Vector, m::Int,\n               ϕ_l::Vector = missings(2), ϕ_r::Vector = missings(2),\n               f1::Vector = missings(2), f2::Vector = missings(2),\n               analitical = nothing)\n\nРисует m-ый кадр решения u. Xₙ, Tₘ — сетки. ϕ_l, ϕ_r — вырожденные решения. f1, f2 — сгенерированные априорные данные. analitical — или функция или сеточные значения аналитического решения.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination-Tuple{Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination","text":"phidetermination(q, u, u_border, Xₙ, N::Int)\n\nРешает ОДУ для нахождения вырожденных корней.\n\ndanger: Danger\nФункция некорректно обрабатыет непостоянные ГУ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve","text":"solve(y₀::Vector, Xₙ::Vector, N::Int,\n           Tₘ::Vector, M::Int,\n           ε::Real, ulₙ::Vector, urₙ::Vector,\n           qₙ::Vector,\n           RP::Function = directRP,\n           jac::Function = ∂directRP_∂y;\n           α::Complex = complex(0.5, 0.5))\n\nTODO: fix docs Функция, которая находит решение с помощью одностадийной схемы Розенброка с комплексным коэффициентом.\n\nНа каждом временном шаге, решение находится как:\n\n    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1\n    endaligned\n\nгде W_1 находится из\n\nbeginaligned\n    leftmathbftextbfE - alpha  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n    qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big)\nendaligned\n\nmathbff_mathbfy(mathbfy(t_m) t_m) — якобиан функции f по вектору y (в момент времени t_m) в момент времени t_m. Эта матрица Якоби имеет следущие ненулевые элементы.\n\nbeginaligned\n     left(f_yright)_11   equiv  fracpartial f_1partial y_1  =  varepsilondfrac-2h^2 - dfracy_2 - u_left(t)2h + q(x_1) \n\n      left(f_yright)_nn - 1   equiv  fracpartial f_npartial y_n - 1  =  varepsilon dfrac1h^2 + dfracy_n2h quad n=overline2 N-1\n\n      left(f_yright)_nn   equiv  fracpartial f_npartial y_n  =   -varepsilon dfrac2h^2 - dfracy_n+1 - y_n-12h + q(x_n) quad n=overline2 N-2\n\n      left(f_yright)_nn + 1   equiv  fracpartial f_npartial y_n + 1  =  varepsilon dfrac1h^2 - dfracy_n2h quad n=overline1 N-2\n\n      left(f_yright)_N - 1N - 1   equiv  fracpartial f_N - 1partial y_N - 1  =   varepsilon dfrac-2h^2 - dfracu_right(t) - y_N - 22h + q(x_N)\nendaligned\n\nArguments\n\ny::Array{<:Real, 1}: Вектор решения системы в текущий момент времени.\nXₙ::Array{<:Real, 1}: Пространственная сетка по x.\nTₘ::Array{<:Real, 1}: Пространственная сетка по x.\nN::Int: Число -интервалов- сетки.\nM::Int: Число -интервалов- сетки.\nε::Real: Малый параметр при старшей производной.\nu_l::Function: Функция левого ГУ.\nu_r::Function: Функция правого ГУ.\nqₙ::Vector: Вектор размера N-1 представляющий \"неоднородность\", см. постановку задачи.\nRP::Function: Функция вычисления вектора f правой части.\njac::Function: Якобиан функции вычисления правой части по вектору y — f_y.\nα::Complex: Коэффициент схемы. При α = 0 — схема Эйлера, при α = complex(0.5, 0.5) — схема Розенброка с комплексным коэффициентом.\n\nReturn\n\nМатрицу N+1, M+1 с искомой функцией на каждом временном шаге.\n\nnote: Note\nДлина вектора length(Xₙ) равняется N+1, сетка передается полностью, вместе с граничными точками.Длина вектора length(Tₘ) равняется M+1, сетка передается полностью, вместе с граничными точками.\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint-Tuple{Array{T,1} where T,Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve_adjoint","text":"warning: Warning\nМассивы Xₙ, Tₘ, u, f1, f2 Передаются как есть! Они переварачиваются внутри функции локально.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.u_init-Tuple{Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.u_init","text":"u_init(x::Real; ε = 0.2) -> Real\n\nНачальные условия в виде (x^2 - x -2) -6 tanh( -3 xi), где xi = fracx - 025ε.\n\nnote: Note\nГраничные условия для этих начальных условий должны быть заданы как (-8, 4).\n\nnote: Note\nВы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.\n\nExample\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)\n11-element Array{Float64,1}:\n -7.993366656356917\n -7.958156688432881\n -5.970893714323723\n  1.600893714323723\n  3.628156688432881\n  3.7433666563569172\n  3.759669571706625\n  3.7899835485135176\n  3.8399991809276504\n  3.9099999592207864\n  3.9999999979697227\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.Φ-Tuple{Array{T,1} where T,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.Φ","text":"Φ(ϕ_l::Vector, ϕ_r::Vector, N::Int) -> ::Vector\n\nВычисляет значение функции на переходном слое phi_l - phi_r2 с помощью левого phi_l и правого phi_r вырожденного корня.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f-Tuple{Array{T,1} where T,Real,Array{T,1} where T,Int64,Real,Function,Function,Function}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f","text":"f(y::Array{<:Real, 1}, t::Real, Xₙ::Array{<:Real, 1},\n  N::Int, ε::Real, u_l::Function, u_r::Function, q::Function)\n\nЗадает qₙ = [ q(x) for x in Xₙ[2:N-1] ] и вызывает f.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f1-Tuple{Array{T,1} where T,Array{T,2} where T,Array{T,1} where T,Int64,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f1","text":"f1(ϕ::Vector, u::Matrix, Xₙ::Vector, N::Int, M::Int)\n\nНаходит значение искомой функции на переходном слое f_1(t) = u(x_tp t) путем поиска точки пересечения u(xt) и ϕ(x).\n\nТочка пересечения находится путем интерполяции функции u(xt) - ϕ(x) = 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints-Tuple{Array{T,1} where T,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints","text":"strip_borderPoints(a::Vector, N) -> Vector\n\nФункция для внутренного использования.\n\nВходящий массив должен быть размера N+1. Обрезает граничные точки слева и справа. Возвращает массив размера N-1.\n\nExample\n\njulia> N = 10; a = rand(N+1);\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints(a, N)\n9-element Array{Float64,1}:\n 0.01692516943937017\n 0.8704971211042747\n 0.09264243610808842\n 0.24863463685945808\n 0.23032297967950588\n 0.35205424704951005\n 0.4762987020192815\n 0.6795780611594018\n 0.5171552197967035\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y-Tuple{Array{T,1} where T,Int64,Array{T,1} where T,Int64,Real,Array{T,1} where T,Array{T,1} where T,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y","text":"∂directRP_∂y(y::Vector, m::Int,\n              Xₙ::Vector, N::Int,\n              ε::Real,\n              ulₙ::Vector, urₙ::Vector,\n              qₙ::Vector)\n\nФункция якобиана для adjointRP.\n\n\n\n\n\n","category":"method"}]
}
