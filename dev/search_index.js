var documenterSearchIndex = {"docs":
[{"location":"adjoint/#Сопряженная-задача-1","page":"Сопряженная задача","title":"Сопряженная задача","text":"","category":"section"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Сопряженная задача формулируется следующим образом:","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"left\nbeginaligned\n    varepsilonfracpartial^2 psipartial x^2 + fracpartial psipartial t = ufracpartial psipartial x +  q(x)psi - \n    hspace12cm -2delta(x-f_1(t))(u(xt)-f_2(t))=0 quad x in (01) quad t in 0T) \n    psi(0t) = 0 quad psi(1t) = 0 quad t in 0T) \n    psi(xT) = 0 qquad x in (01)\nendaligned\nright","category":"page"},{"location":"adjoint/#","page":"Сопряженная задача","title":"Сопряженная задача","text":"Перепишем её в удобном виде для применений метода жесткий прямых ```math \\left{ \\begin{aligned}     \\frac{\\partial \\psi}}{\\partial t} = &\\varepsilon\\frac{\\partial^2 \\psi}}{\\partial x^2} + u}\\frac{\\partial \\psi}}{\\partial x} +  q}(x)\\,\\psi} - \\\n    &\\hspace{1.2cm} -2\\delta(x-f1(t))(u}(x,t)-f2(t)), \\quad x \\in (0,1), \\quad t \\in [0,T), \\\n    &\\psi}(0,t) = 0, \\quad \\psi}(1,t) = 0, \\quad t \\in [0,T), \\\n    &\\psi}(x,T) = 0, \\qquad x \\in (0,1). \\end{aligned} \\right. `","category":"page"},{"location":"apriordata/#Нахождение-вырожденных-корней-1","page":"Генерирование априорной информации","title":"Нахождение вырожденных корней","text":"","category":"section"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Левое вырожденное решение","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^ldx = q(x) quad x in (0 1 \n     phi^l(0) = u_l\nendaligned\nright","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Правое вырожденное решение","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"left\nbeginaligned\n     fracd phi^rdx = q(x) quad x in 0 1) \n     phi^r(1) = u_r\nendaligned\nright","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Пересечение функции Phi(x) = abs(phi^l - phi^r)2 + phi^l с функцией u(x t) и будет определять положение переходного слоя x_tp = f1(t) и значение функции u(x_tp(t)t) = f2(t) в этой точке.","category":"page"},{"location":"apriordata/#","page":"Генерирование априорной информации","title":"Генерирование априорной информации","text":"Для поиска положения переходного слоя x_tp в момент времени t0 найдем x при котором Phi(x) - u(x t0) = 0.","category":"page"},{"location":"model/#Тестирование-1","page":"Проверка на модельном решении","title":"Тестирование","text":"","category":"section"},{"location":"model/#Проверка-корректности-решения-прямой-задачи-1","page":"Проверка на модельном решении","title":"Проверка корректности решения прямой задачи","text":"","category":"section"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Зададим следующую пробную функцию: g(xt) = (1-2t) sin(pi x) и найдем её производные:","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"fracpartial gpartial x = pi (1-2t) cos(pi x)\nfracpartial^2 gpartial x^2 = - pi^2 (1 - 2t) sin(pi x)\nfracpartial gpartial t = -2 sin(pi x).","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Подставим найденные производные в исходное уравнение (см.Постановка задачи), таким образом определив g_d (от англ. discrepancy).","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"g_d(xt) = 2 sin(pi x) - varepsilon pi^2 (1 - 2t) sin(pi x) +\npi (1 - 2t)^2 sin(pi x) cos(pi x) - q(x) (1 -2t) sin(pi x)","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Таким образом, пробная функция g будет являться решением уравнения","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u + g_d(xt) quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Найдем решение следующим образом:","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1 \n        leftmathbftextbfE - dfrac1 + i2  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n        qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big) + g_d(mathbfX_nfract_m + 1 + t_m2)\n    endaligned","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"где g_d(mathbfX_n) — значения g_d на сетке x_1 x_x ldots x_N, т.е. на сетке mathbfX_n без граничных точек.","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Такая проверка корректности решения применяется в юнит тесте \"tests/direct_with_model.jl\".","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"using Test, ForwardDiff\nusing NonLinearReactionAdvectionDiffusionWithFrontData\n\nu_l(t) = 0\nu_r(t) = 0\nε = 0.1;\na, b = 0, 1;\nt₀, T = 0, 1;\nN, M = 40, 80;\nh = (b-a)/N;\nτ = (T-t₀)/M;\nXₙ = [a  + n*h for n in 0:N];\nTₘ = [t₀ + m*τ for m in 0:M];\nq(x) = sin(3 * π * x);\nu = zeros(M+1, N+1);\n\n# Зададим модельную функцию и невязку, получаемую после подстановки `g` в исходное уравнение\ng(x, t) = (1 - 2t)*sin(π*x);\ng_d(x,t) =  - ε * π^2 * (1 - 2t) * sin(π * x) + π * (1 - 2t)^2 * sin(π * x) * cos(π * x) - q(x) * (1 -2t) * sin(π * x) + 2 * sin(π * x);\n\ny = g.( (Xₙ[n] for n in 2:N), 0 );\nqₙ = [ q(x) for x in Xₙ[2:N] ];\n\n# Модельное решение найденное с помощью известного аналитического решения\nmodel = [ g(x,t) for x in Xₙ, t in Tₘ];\n\n# Создадим функцию, которая будет вычислять вектор правой части с добавлением невязки\nRP(y, t, Xₙ, N, ε, u_l, u_r, qₙ) = f(y, t, Xₙ, N, ε, u_l, u_r, qₙ) - g_d.(Xₙ[2:N], t)\n# Хоть мы и конструируем якобиан с помощью автоматического дифференцирования, примите во внимание, что\n# Якобиан ``f_y`` при добавлении `g_d` останется без изменений, т.к. `g_d` зависит только от ``x,t``.\n# То, что он не зависит от добавления `g_d` можно убедиться изменением порядка этих двух строк, ну а так же на бумаге.\nj(y, t, Xₙ, N, ε, u_l, u_r, qₙ) = ForwardDiff.jacobian( z -> RP(z, t, Xₙ, N, ε, u_l, u_r, qₙ), y)\n\nu= solve!(y, Xₙ, Tₘ, N, M, ε, u_l, u_r, qₙ, RP, j);\n@test isapprox(model, u, rtol = 1E-3)","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"Сохраним анимацию решения на модельной функции.","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"make_gif(u, Xₙ, Tₘ, g; frame_skip = div(M,30), frames_to_write=80, name=\"solution_model.gif\");\nnothing #hide","category":"page"},{"location":"model/#","page":"Проверка на модельном решении","title":"Проверка на модельном решении","text":"(Image: )","category":"page"},{"location":"reference/#Справочник-1","page":"Справочник","title":"Справочник","text":"","category":"section"},{"location":"reference/#","page":"Справочник","title":"Справочник","text":"Modules = [NonLinearReactionAdvectionDiffusionWithFrontData]","category":"page"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f-Tuple{Array{#s12,1} where #s12<:Real,Real,Array{#s16,1} where #s16<:Real,Int64,Real,Function,Function,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f","text":"f(y::Vector, 1}, t::Real, Xₙ::Vector, 1},\n  N::Int, ε::Real, u_l::Function, u_r::Function, qₙ::Vector) -> ::Vector\n\nФункция вычисляет вектор правой части с помощью конечно-разностной аппроксимации пространственных производных.\n\nЕсли записать систему в следующем виде:\n\n    left\n    beginaligned\n        dfracd mathbftextbfyd t = mathbftextbff  (mathbftextbfyt) quad t in (t_0T\n        mathbftextbfy(t_0) = mathbftextbfy_init\n    endaligned\n    right\n\nгде\n\n    beginaligned\n        mathbftextbfy = big(u_1  u_2   ldots  u_N - 1 big)^T \n        mathbftextbff = big(f_1  f_2  ldots  f_N - 1big)^T \n        mathbftextbfy_init = big(u_init (x_1)  u_init (x_2)  ldots  u_init (x_N - 1) big)^T\n    endaligned\n\nu_init(x_n)\n\nвычисляется с помощью u_init(x).\n\nТо текущая функция определяет вектор-функцию mathbftextbff следующим образом:\n\n    beginaligned\n        f_1 =       varepsilon dfracy_2        - 2y_1       + u_left(t)h^2 + y_1       dfracy_2        - u_left(t)2h - q(x_1) y_1 \n        f_n =       varepsilon dfracy_n + 1    - 2y_n       + y_n - 1h^2   + y_n       dfracy_n + 1    - y_n - 12h   - q(x_n) u_n quad n=overline2 N-2 \n        f_N - 1 = varepsilon dfracu_right(t) - 2y_N - 1 + y_N - 2h^2   + y_N - 1 dfracu_right(t) - y_N - 22h   - q(x_N-1) y_N-1\n    endaligned\n\nArguments\n\ny::Array{<:Real, 1}:  Вектор размера N-1 решения системы в текущий момент времени\nt::Real:  Текущий момент времени.\nXₙ::Array{<:Real, 1}: Пространственная сетка по x.\nN::Int: Число -интервалов- сеткию\nε::Real: Малый параметр при старшей производной.\nu_l::Function: Функция левого ГУ.\nu_r::Function: Функция правого ГУ.\nq::Vector: Вектор размера N-1 представляющий \"неоднородность\", см. постановку задачи.\n\nnote: Note\nДлина вектора length(Xₙ) равняется N+1, сетка передается полностью, вместе с граничными точками.\n\nwarning: Warning\nФункция работает по формулам для равномерной сетки!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f-Tuple{Array{#s14,1} where #s14<:Real,Real,Array{#s15,1} where #s15<:Real,Int64,Real,Function,Function,Function}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f","text":"f(y::Array{<:Real, 1}, t::Real, Xₙ::Array{<:Real, 1},\n  N::Int, ε::Real, u_l::Function, u_r::Function, q::Function)\n\nЗадает qₙ = [ q(x) for x in Xₙ[2:N-1] ] и вызывает f.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.make_gif","text":"make_gif(u::Matrix, Xₙ::Vector, Tₘ::Vector, analitical=nothing;\n        frames_to_write::Int = -1, frame_skip::Int=-1, name=\"solution.gif\")\n\nРисует gif анимацию решения каждый frame_skip кадр, вплоть по frames_to_write-ый кадр, сохраняет под именем name.\n\nТак же рисует аналитическое решение analitic(x,t), если таково передано.\n\nTODO: Fix doc\n\n\n\n\n\n","category":"function"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve!-Tuple{Array{#s14,1} where #s14<:Real,Array{#s13,1} where #s13<:Real,Array{#s12,1} where #s12<:Real,Int64,Int64,Real,Function,Function,Array{T,1} where T,Function,Function}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve!","text":"solve!(y::Array{<:Real, 1}, Xₙ::Array{<:Real, 1}, Tₘ::Array{<:Real, 1}, N::Int,\n            M::Int, ε::Real, u_l::Function, u_r::Function, qₙ::Vector,\n            RP::Function, jac::Function ; α::Complex = complex(0.5, 0.5)) -> Matrix\n\nФункция, которая находит решение с помощью одностадийной схемы Розенброка с комплексным коэффициентом.\n\nНа каждом временном шаге, решение находится как:\n\n    beginaligned\n        mathbftextbfy(t_m + 1) = mathbftextbfy(t_m) + (t_m + 1 - t_m)  mathrmRe  mathbftextbfw_1\n    endaligned\n\nгде W_1 находится из\n\nbeginaligned\n    leftmathbftextbfE - alpha  (t_m + 1 - t_m)  mathbftextbff_mathbftextbfyBig(mathbftextbfy(t_m)t_mBig)right  mathbftextbfw_1 = \n    qquadqquadqquadqquadquad = mathbftextbff  Big(mathbftextbfy(t_m)fract_m + 1 + t_m2Big)\nendaligned\n\nmathbff_mathbfy(mathbfy(t_m) t_m) — якобиан функции f по вектору y (в момент времени t_m) в момент времени t_m. Эта матрица Якоби имеет следущие ненулевые элементы.\n\nbeginaligned\n     left(f_yright)_11   equiv  fracpartial f_1partial y_1  =  varepsilondfrac-2h^2 - dfracy_2 - u_left(t)2h + q(x_1) \n\n      left(f_yright)_nn - 1   equiv  fracpartial f_npartial y_n - 1  =  varepsilon dfrac1h^2 + dfracy_n2h quad n=overline2 N-1\n\n      left(f_yright)_nn   equiv  fracpartial f_npartial y_n  =   -varepsilon dfrac2h^2 - dfracy_n+1 - y_n-12h + q(x_n) quad n=overline2 N-2\n\n      left(f_yright)_nn + 1   equiv  fracpartial f_npartial y_n + 1  =  varepsilon dfrac1h^2 - dfracy_n2h quad n=overline1 N-2\n\n      left(f_yright)_N - 1N - 1   equiv  fracpartial f_N - 1partial y_N - 1  =   varepsilon dfrac-2h^2 - dfracu_right(t) - y_N - 22h + q(x_N)\nendaligned\n\nArguments\n\ny::Array{<:Real, 1}: Вектор решения системы в текущий момент времени.\nXₙ::Array{<:Real, 1}: Пространственная сетка по x.\nTₘ::Array{<:Real, 1}: Пространственная сетка по x.\nN::Int: Число -интервалов- сетки.\nM::Int: Число -интервалов- сетки.\nε::Real: Малый параметр при старшей производной.\nu_l::Function: Функция левого ГУ.\nu_r::Function: Функция правого ГУ.\nqₙ::Vector: Вектор размера N-1 представляющий \"неоднородность\", см. постановку задачи.\nRP::Function: Функция вычисления вектора f правой части.\njac::Function: Якобиан функции вычисления правой части по вектору y — f_y.\nα::Complex: Коэффициент схемы. При α = 0 — схема Эйлера, при α = complex(0.5, 0.5) — схема Розенброка с комплексным коэффициентом.\n\nReturn\n\nМатрицу N+1, M+1 с искомой функцией на каждом временном шаге.\n\nnote: Note\nДлина вектора length(Xₙ) равняется N+1, сетка передается полностью, вместе с граничными точками.Длина вектора length(Tₘ) равняется M+1, сетка передается полностью, вместе с граничными точками.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.solve!-Tuple{Array{#s22,1} where #s22<:Real,Array{#s23,1} where #s23<:Real,Array{#s24,1} where #s24<:Real,Int64,Int64,Real,Function,Function,Array{T,1} where T}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.solve!","text":"solve!(y::Array{<:Real, 1}, Xₙ::Array{<:Real, 1}, Tₘ::Array{<:Real, 1}, N::Int,\n            M::Int, ε::Real, u_l::Function, u_r::Function, qₙ::Vector; α::Complex = complex(0.5, 0.5))\n\nAlias для вызова solve!(y, Xₙ, Tₘ, N, M, ε, u_l, u_r, qₙ, f, j);, где f = NonLinearReactionAdvectionDiffusionWithFrontData.f, j(y, t, Xₙ, N, ε, u_l, u_r, q) = ForwardDiff.jacobian( z -> f(z, t, Xₙ, N, ε, u_l, u_r, qₙ), y).\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.u_init-Tuple{Real}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.u_init","text":"u_init(x::Real; ε = 0.2) -> Real\n\nНачальные условия в виде (x^2 - x -2) -6 tanh( -3 xi), где xi = fracx - 025ε.\n\nwarning: Warning\nГраничные условия для этих начальных условий должны быть заданы как (-8, 4).\n\nnote: Note\nВы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.\n\nExample\n\njulia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)\n11-element Array{Float64,1}:\n -7.993366656356917\n -7.958156688432881\n -5.970893714323723\n  1.600893714323723\n  3.628156688432881\n  3.7433666563569172\n  3.759669571706625\n  3.7899835485135176\n  3.8399991809276504\n  3.9099999592207864\n  3.9999999979697227\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.delta-Tuple{Any,Any,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.delta","text":"delta(x, Xₙ, x₀) -> ::Number\n\nВычисляет конечно разностную аппроксимацию дельта функции delta(x x₀) на сетке Xₙ исходя из intlimits_a^b delta(x x₀) dx = 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.f1-NTuple{5,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.f1","text":"f1(ϕ, u, Xₙ, N, M)\n\nНаходит значение искомой функции на переходном слое f_1(t) = u(x_tp t) путем поиска точки пересечения u(xt) и ϕ(x).\n\nТочка пересечения находится путем интерполяции функции u(xt) - ϕ(x) = 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.jacobian-NTuple{6,Any}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.jacobian","text":"warning: Warning\nОно не работает!\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination-Tuple{Any,Any,Any,Any,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.phidetermination","text":"phidetermination(q, u, u_border, Xₙ, N::Int)\n\nРешает ОДУ для нахождения вырожденных корней.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NonLinearReactionAdvectionDiffusionWithFrontData.Φ-Tuple{Array{T,1} where T,Array{T,1} where T,Int64}","page":"Справочник","title":"NonLinearReactionAdvectionDiffusionWithFrontData.Φ","text":"Φ(ϕ_l::Vector, ϕ_r::Vector, N::Int) -> ::Vector\n\nВычисляет значение функции на переходном слое (phi_l - phi_r)2 с помощью левого phi_l и правого phi_r вырожденного корня.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Главная","title":"Главная","text":"DocTestSetup = quote\n    using NonLinearReactionAdvectionDiffusionWithFrontData\nend\n","category":"page"},{"location":"#Главная-1","page":"Главная","title":"Главная","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"","category":"page"},{"location":"#Постановка-задачи-1","page":"Главная","title":"Постановка задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"left\nbeginaligned\n    varepsilonfracpartial^2 upartial x^2 - fracpartial upartial t = -u fracpartial upartial x +  q(x)u quad x in (01) quad t in (0T) \n    u(0t) = u_left(t) quad u(1t) = u_right(t) quad t in (0T) \n    u(xt) = u_init(x) qquad x in 01\nendaligned\nright","category":"page"},{"location":"#Пример-решения-прямой-задачи-1","page":"Главная","title":"Пример решения прямой задачи","text":"","category":"section"},{"location":"#","page":"Главная","title":"Главная","text":"Зададим параметры.","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"using NonLinearReactionAdvectionDiffusionWithFrontData\nusing Plots\n\nu_l(t) = -8\nu_r(t) = 4\nε = 0.2;\na, b = 0, 1;\nt₀, T = 0, 1;\nN, M = 40, 80;\nh = (b-a)/N;\nτ = (T-t₀)/M;\nXₙ = [a  + n*h for n in 0:N];\nTₘ = [t₀ + m*τ for m in 0:M];\nq(x) = sin(3 * π * x);\nu = zeros(M+1, N+1);\nnothing #hide","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Зададим начальное приближение u_init","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"y = u_init.( Xₙ[n] for n in 2:N );\nqₙ = [ q(x) for x in Xₙ[2:N] ];","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"Решим задачу solve! и построим gif решения make_gif","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"u= solve!(y, Xₙ, Tₘ, N, M, ε, u_l, u_r, qₙ)\nmake_gif(u, Xₙ, Tₘ; frame_skip = div(M,30), frames_to_write=80, name=\"solution.gif\");\nnothing # hide","category":"page"},{"location":"#","page":"Главная","title":"Главная","text":"(Image: )","category":"page"}]
}
