# Всякие вспомогательные функции

@doc raw"""
    meshformation(a::Int, b::Int,
                  x_tp::Real, ε::Real,
                  N::Int = 50,
                  C_i::Real = 1.0, K_i::Real = 1.0,
                  C_b::Real = 1.0, K_b::Real = 1.0)

Возвращает кусочнораномерную сетку со сгущением на границах и на переходном слое.

# Arguments
- `a::Int`      Левая граница.
- `b::Int`      Правая граница.
- `x_tp::Real`  Положение переходного слоя.
- `ε::Real`     Малый параметр при старшей производной.
- `C_i::Real`   Масштабирующий коэффициент для ширины внутреннего сгущения.
- `K_i::int`    Масштабирующий коэффициент количества интервалов внутреннего сгущения.
- `C_b::Real`   Масштабирующий коэффициент для ширин пограничных сгущений.
- `K_b::Int`    Масштабирующий коэффициент количеств интервалов пограничных сгущений.
- `K::Int`      Кол-во интервалов вне всех сгущений.

# Return
Кусчноравномерную сетк, на эскизе чтоками изображены узлы сетки и помечены характерные
точки использованные в коде функции, для формирования сетки.
```md
    bb                            ai   bi                                ab
    ↓                             ↓     ↓                                ↓
.....  .  .  .  .  .  .  .  .  .  .......  .  .  .  .  .  .  .  .  .  .  ......
```
"""
function meshformation(a::Int, b::Int,
                       x_tp::Real, ε::Real,
                       N::Int = 50,
                       C_i::Real = 1.0, K_i::Real = 1.0,
                       C_b::Real = 1.0, K_b::Real = 1.0)

    width = abs(ε * log(ε));                        # Толщина сгущения, одинаковая для внутреннего и переходных
    N_b = N * K_b;                                  # Кол-во интервалов на пограничных сгущениях
    N_i = N * K_i;                                  # Кол-во интервалов на внутреннем сгущении

    δb = C_b * width / N_b;                         # Шаг сетки на пограничных сгущениях
    Xl = [ a + i*δb for i in 0:N_b];                # Сетка левого сгущения
    Xr = [ b - width + i*δb for i in 0:N_b];        # Сетка правого сгущения

    if last(Xl) > first(Xr)
        throw(ErrorException("Пограничные сгущения пересекаются.
                             Возможно `ε` недостаточно маленькая"));
    end

    # Характерные точки, см `# Return`
    # `bb` — сокращение от b_border, правая граница пограничных сгущений
    # `ai` — сокращение от a_interior, левая граница внутреннего сгущения
    bb = last(Xl);                                  # Правая граница сгущения на левом пограничном слое
    ai = x_tp - width/2;                            # Левая граница сгущения на внутреннем слое
    @assert bb < ai "Внутренее сгущение пересекается с левым пограничным"

    # Характерные точки, см `# Return`
    # `ab` — сокращение от a_border, левая граница пограничных сгущений
    # `bi` — сокращение от b_interior, правая граница внутреннего сгущения
    bi = x_tp + width/2;                            # Правая граница сгущения на внутреннем слое
    ab = first(Xr);                                 # Левая граница сгущения на правом пограничном слое
    @assert bi < ab "Внутренее сгущение пересекается с правым пограничным"

    δi = C_i * width / N_i;                         # Шаг сетки на внутреннем сгущении
    Xi = [ ai + i*δi for i in 0:N_i];               # Сетка внутреннего сгущения

    N_dl = Real(ai - bb) / ( ab - bi);              # `N_dl` кол-во обычных точек слева от вн. сгущения, от N_default_left
    @debug "Характерные точки сетки" bb ai bi ab
    @debug "Длины участков без сгущений" ( ai - bb ) ( ab - bi )

    length_dl = abs(ai - bb);                       # Длина стандартного участка без сгущений, слева от вн. сгущения
    length_dr = abs(ab - bi);                       # Длина стандартного участка без сгущений, справа от вн. сгущения

    pl = length_dl / (length_dl + length_dr);       # Доля точек в левом стандартном участке
    pr = length_dr / (length_dl + length_dr);       # Доля точек в левом стандартном участке
    N_l = Int(round(pl * N));                       # Кол-во интервалов на левом участке без сгущений
    N_r = N - N_l;                                  # Кол-во интервалов на правом участке без сгущений
    @assert N_l + N_r == N "Что-то пошло не так с долями точек слева и справа"
    @assert N_r == Int(round(pr * N)) "Что-то пошло не так с долями точек слева и справа"

    @debug "Доля точек в сгущениях" pl pr
    @debug "Кол-во точек" N_l N_r

    δ = (length_dl + length_dr) / N;                # Шаг сетки вне сгущений

    Xdl = [bb + δ*i for i in 1:N_l-1];              # Сетка левого стандартного участка
    Xdr = [bi + δ*i for i in 1:N_r-1];              # Сетка правого стандартного участка

    return [Xl; Xdl; Xi; Xdr; Xr]
end

@doc raw"""
    strip_borderPoints(a::Vector, N) -> Vector

Функция для внутренного использования.

Входящий массив должен быть размера `N+1`.
Обрезает граничные точки слева и справа.
Возвращает массив размера `N-1`.

# Example
```jldoctest
julia> N = 10; a = collect(1:N+1);

julia> NonLinearReactionAdvectionDiffusionWithFrontData.strip_borderPoints(a, N)
9-element Array{Int64,1}:
  2
  3
  4
  5
  6
  7
  8
  9
 10
```
"""
function strip_borderPoints(a::Vector, N)
    @assert length(a) == N+1 "Размерность входного вектора отличается от $(N+1)"
    return a[2:N]
end

function strip_borderPoints(a::Matrix, N)
    @assert size(a,1) == N+1 "Размерность входного вектора отличается от $(N+1)"
    return a[2:N,:]
end

@doc raw"""
    u_init(x::Real; ε::Real = 0.2, x_tp = 0.15) -> Real

Начальные условия в виде $(x^2 - x -2) -6 \tanh( -3 \xi)$, где $\xi = \frac{x - x_tp}{ε}$.
`x_tp` — положение внутрннего переходного слоя.

!!! note
    Граничные условия для этих начальных условий должны быть заданы как `(-8, 4)`.

!!! note
    Вы вольны устанавливать начальные условия на свое усмотрения, эта функция внесена в модуль для удобства повествования.

# Example
```jldoctest
julia> NonLinearReactionAdvectionDiffusionWithFrontData.u_init.(0:0.1:1)
11-element Array{Float64,1}:
 -7.868156688432881
 -5.900893714323723
  1.650893714323725
  3.6581566884328813
  3.753366656356917
  3.749669571706625
  3.7599835485135173
  3.7899991809276505
  3.839999959220786
  3.909999997969723
  3.999999999898918
```
"""
function u_init(x::Real; ε::Real = 0.2, x_tp = 0.15)
    ξ = (x - x_tp) / ε;
    return ((x^2 - x - 2) - 6 * tanh(-3 * ξ))
end

@doc raw"""
    delta(x, Xₙ, x₀ = 0) -> ::Real

Вычисляет конечно разностную аппроксимацию дельта функции ``\delta(x; x₀)`` на сетке `Xₙ` исходя из ``\int\limits_a^b \delta(x; x₀) dx = 1``.
"""
function delta(x::Real, Xₙ::Vector, x₀::Real = 0)
    if ! (Xₙ[1] <= x <= Xₙ[end])
        throw(DomainError("`x` находится вне `Xₙ`"))
    end
    if ! (Xₙ[1] <= x₀ < Xₙ[end])
        throw(DomainError("`x₀` находится вне полуоткрытого отрезка ``[Xₙ[1], Xₙ[end])`` [$(Xₙ[1]), $(Xₙ[end]))"))
    end

    N = length(Xₙ) - 1
    out = 0.0;

    for n in 1:N
        if ( x >= Xₙ[n]) && ( x < Xₙ[n+1] )
            if ( x₀ >= Xₙ[n] ) && ( x₀ < Xₙ[n+1])
                out = 1 / ( Xₙ[n+1] - Xₙ[n] )
            end
        end
    end
    return out;
end

@doc raw"""
    deltaw(n::Int, x₀::Real, Xₙ::Vector, N::Int)

Вычисляет ``\delta(x - x₀)``, где `x = Xₙ[n]`.
`n` — номер узла в сетке `Xₙ`(без граничных точек).
Использует более точную конечно разностную аппроксимацию дельта функции [`δw`](@ref).
"""
function deltaw(n::Int, x₀::Real, Xₙ::Vector, N::Int)

    @assert length(Xₙ) == N-1
    @assert 1 <= n <= N-1 "`n` вне корректного отрезка"

    out = δw(Xₙ[n] - x₀)

    return out;
end

@doc raw"""
    δw(x::Real; ω = 0.001)

Линейная аппроксимация ``δ(x)``, `ω` — эвристический парамет.
Подбирается так, чтобы невязка сопряженной задачи
``2 \delta( x - f_1(t)) ( u(x,t) - f_2(t))`` при подстановке
в неё `u(x,t;q)` истинного `q` обнулялась почти везде, **но не всюду**.
"""
function δw(x::Real; ω = 0.001)
    if abs(x/ω) <= 1
        return ( 1 - abs(x/ω))/ω
    else
        return 0.0
    end
end
