# Генерация экспериментальной информации

## Вырожденные решения

Положив малый параметр ``\varepsilon = 0`` равным нулю, на каждом временном
шаге определим задачи Коши для левого вырожденного решения ``\varphi_l(x)``
и правого ``\varphi_r(x)`` следующим образом

```math
\left\{
\begin{array}{c}
    & \frac{d \phi_l^m}{dx} = q(x), & \quad x \in (0, 1], \\
    & \phi_l^m = u_l^m &
\end{array}
\right.
\qquad
\left\{
\begin{array}{c}
    & \frac{d \phi_r^m}{dx} = q(x), \quad x \in [0, 1), \\
    & \phi_r^m = u_r^m
\end{array}
\right.
```
Эти обыкновенные дифференциальные уравнения решим интегрированием:
```math
\left\{
\varphi_0 = \varphi_b \\
\varphi_{n+1}^m = \varphi_{n}^m + (q_{n+1} - q_{n})(x_{n+1} - x_{n}) / 2
\right.
```
Где ``\varphi_b`` -- это соответствующее граничное условие, а ``x_n`` узлы сетки
по пространству, поданной в соответствующем направлении.

!!! tip
    Записать формулы интегрирования ОДУ нормально.

Решением семейства этих задач Коши будут ``(\varphi_l)_n^m, (\varphi_r)_n^m``.
Определим полуразность вырожденных решений
``\varPhi_n^m = |(\varphi_r)_n^m - (\varphi_l)_n^m|/2 + (\varphi_l)_n^m``

Положение переходного слоя ``f_1(t)`` определяется как аргумент ``x_{tp}``
при котором функция ``u(x,t)`` пересекается с полуразностью вырожденных решений
``\varPhi``.
Имея сеточные значения ``u_n^m, \varPhi_k^m``, где функции определены на разных
сетках, сначала нужно привести их к значениям на одной сетке.
После чего, построить сеточную функцию ``v_k = u_k^m - \varPhi_k^m``, после чего
найти ноль функции ``v_k``.
Ноль функции находится с помощью интерполяции обратной функции ``v_k^{-1}(0)``.

Или в другой постановке:
```math
f_1(t) \equiv x_{tp}(t) = \argmin_x |u(x,t) - \varPhi(x,t)|
```

Зная положение переходного слоя, интерполяцией найдём значение искомой функции
на переходном слое ``f_2(t) = u(x_{tp}(t), t)``.

## Программная реализация

* Задачи коши решаются [`phidetermination`](@ref). Для правого вырожденного
    решения необходимо подать ключевое слово `reverseX = true`, чтобы
    сигнализировать о обратном направлении интегрирования по ``x``.
    Решение находится интегрированием по квадратурным формулам парабол.

* Полуразность находится тривиальной функцией [`Φ`](@ref).

* Положение переходного слоя определяется функцией [`f1`](@ref), которая в
    каждый момент времени вызывает функцию
    [`NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros`](@ref),
    которая реализует вышеописанный алгоритм поиска нуля функции.

* Значения функции на переходном слое определяется [`f2`](@ref), которая
    так же вызывает
    [`NonLinearReactionAdvectionDiffusionWithFrontData.find_f_zeros`](@ref)
    в каждый момент времени, только с другими аргументами.

!!! tip
    Математически формализоваться эту задачу через поиск нуля "новой"
    функции.

* Всё это вместе, одной строчкой, делается с помощью
    [`generate_obs_data`](@ref).
