# Проверка корректности решения прямой задачи

Применим метод пробной функции или контрольной невязки.
Это позволит сравнивать решение, получаемое нашей схемой, с аналитическим
решением, даже если мы не можем найти аналитическое решение исходного
уравнения.

Идея проверки заключается в выборе некоторой известной пробной функции,
например, ``g(x,t)``, которая не является решением исходного уравнения.
Подставив пробную функцию уравнение, оно не обращается в тождество.
Если преобразовать уравнение путем вычитания невязки, полученной в прошлом
действии, то мы получим новое уравнение, для которого уже ``g(x,t)`` ---
решение.

После этого, мы решаем решаем модифицированное уравнение с помощью нашей схемы,
в которой нужно лишь подправить функцию возвращающую вектор правой части ---
нужно дополнительно вычесть невязку, формулу для которой мы нашли аналитически.

## Алгоритм

Зададим следующую пробную функцию ``g(x,t) = (1-2t) \sin(\pi x)``.
Найдем её производные:

* ``\frac{\partial g}{\partial x} = \pi (1-2t) \cos(\pi x)``
* ``\frac{\partial^2 g}{\partial x^2} = - \pi^2 (1 - 2t) \sin(\pi x)``
* ``\frac{\partial g}{\partial t} = -2 \sin(\pi x)``.

Подстановка пробной функции в исходной уравнение
(см. [Постановка обратной задачи](@ref)), позволит нам определить
``g_d``
```math
g_d(x,t) = 2 \sin(\pi x) - \varepsilon \pi^2 (1 - 2t) \sin(\pi x) +
\pi (1 - 2t)^2 \sin(\pi x) \cos(\pi x) - q(x) (1 -2t) \sin(\pi x)
```

Таким образом, пробная функция ``g`` будет являться решением уравнения

```math
\left\{
\begin{aligned}
    &\varepsilon\frac{\partial^2 u}{\partial x^2} -
    \frac{\partial u}{\partial t} = -u \frac{\partial u}{\partial x} +
    q(x)\,u - g_d(x,t), \quad x \in (0,1), \quad t \in (0,T], \\
    &u(0,t) = u_{left}(t), \quad u(1,t) = u_{right}(t), \quad t \in (0,T], \\
    &u(x,t) = u_{init}(x), \qquad x \in [0,1], t = 0.
\end{aligned}
\right.
```

Так как мы хотим тестировать наш алгоритм решения прямой задачи, то, очевидно,
мы будет применять тот же метод и те же функции.
Модификация схемы Розенброка будет заключаться в добавлении соответствующего
слагаемого в вектор правой части.
Это слагаемое не содержит ``y_i``, значит его добавление никак не повлияет
на якобиан.

Так, аргументами функции [`solve`](@ref), кроме параметров
определяющих саму начально-краевую задачу, будут функции модифицированной правой
части и старой функции якобиана.
Во втором тесте кроме модифицированной правой части `RP` на вход подается
якобиан полученный автоматическим дифференцированием, чтобы отловить ошибки в
формулах якобиана.

Такая проверка корректности решения применяется в unit тесте
`"tests/direct_with_model.jl"`. Здесь мы сделаем `include`, а
[Literate.jl](https://github.com/fredrikekre/Literate.jl) включит
текст теста вместе с результатами его выполнения  в этот md файл (_см.
`make.jl`, строго говоря, конкретно здесь мы дописываем в этот файл содержимое
файла, который сгенерирует `Litarate.jl` из `dt_direct.jl`_).
