# # Примеры
#
# На этой странице мы делаем `include` примеров,
# которые лежат в корневом каталоге пакета в папке `"examples/"`.
#
# [Literate.jl](https://github.com/fredrikekre/Literate.jl) включает
# текст этих примеров и в md файл.
#
#src `#src` это комментарии даже для Literate.jl
#src `#md` Строки Literate.jl включит только в md файлы.
#
#src Перед всматриванием в следующий блок, посмотри `docs/make.jl`.
#src Там, скормив этот скрипт Literate.jl мы получим страницу
#src `docexample_adjoint.md`. Именно её будет обрабатывать Documenter.jl
#
#md # ```@contents
#md # Pages = [ "docexample_adjoint.md" ]
#md # Depth = 5
#md # ```




include("examples/example_adjoint.jl")

# ### Визуализация

# Мы не можем строить большие анимации на стороне `Travis`-a.
# Если мы на CI, то будем рисовать только 10 кадров.
# Если мы генерируем документацию локально, то рисуем 80 кадров.
isTravis = in("Travis", keys(ENV))
ftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];

# На отрисовку, решение сопряженной задачи передадим в инвертированном времени.
# Передадим свою подпись к графиками с помощью keyword `label="\\psi"`,
# не забыл про экранировку спец символа
make_gif(reverse(ψ, dims=2), XX, Tₘ;
         label="\\psi",
         name="solution_adjoint_ex1.gif",
         frames_to_write = ftw)

# Результат должен быть около нулевой, ведь в качестве текущего приближения `q` мы взяли искомое,
# а при нем — градиент должен обнуляться.






include("examples/example_adjoint_nonuniform.jl")

# Результат должен быть около нулевой, ведь в качестве текущего приближения `q` мы взяли искомое,
# а при нем — градиент должен обнуляться.

# ### [Контроль параметра аппроксимации дельта-функции](@id empiric-control)
#
# Проведем контроль выбора априорного параметра в аппроксимации дельта-функции.
# На точных данных, эта неоднородность должна быть нулевой почти везде исходя
# из следующих соображений:
# * сопряженная задача — ретроспективная,
# * её начальные условие — нулевые,
# * если из уравнения вычеркнуть эту неоднородность, то решением с такими
#   ГУ и НУ будет тривиальное нулевое решение.
# * исходя из [формулировки градиента](@id function-gradient),
# * нулевое решение сопряженной задачи даст нам нулевой градиент,
#   а значит мы нашли решение обратной задачи.
#
# Выбор этого параметра **значительно** влияет на вычисление градиента, а
# значит и на решение, к которому сойдется итерационный процесс.
using  NonLinearReactionAdvectionDiffusionWithFrontData: heterogeneity;
using LaTeXStrings, Plots;
Uₙₘ = u[2:N, :];
X = XX[2:N, :];
H = [  - heterogeneity(n, m, X[:, m], N, Tₘ, M, Uₙₘ, f1_data, f2_data, w) for n in 1:N-1, m in 1:M+1]
heatmap(H', title=L"-2 δ( x - f_1(t))(u(f1(t), t) - f2(t) ")

# ### Визуализация
ftw = isTravis ? range(1, stop = M+1, length=9) : [1; 2:div(M+1, 80):M+1];

make_gif(reverse(ψ, dims=2), XX, Tₘ;
         label="\\psi",
         name="solution_adjoint_ex3.gif",
         frames_to_write = ftw)
