# ## Решение прямой задачи
# Здесь мы зададим параметры вручную, дав комментарии о них.
# После, во всех следующих примерах,
# будем задавать параметры с помощью стандартной функции [`NonLinearReactionAdvectionDiffusionWithFrontData.dparams`](@ref)
using NonLinearReactionAdvectionDiffusionWithFrontData

u_l(t) = -8 + sin(2*π / T * t); # Прямая задача может быть с неоднородными ГУ
u_r(t) =  4 +4sin(-2*π / T * t);# Но в дальнейшем, будем использовать только однородные.
qf(x) = 4*sin(3 * π * x);       # Коэффициент линейного усиления, который в обратной
                                ## задаче необходимо определить, но при генерации априорной
                                ## информации мы задаем некоторый известный коэффициент, который
                                ## и будем определять имея априорную информацию.
ε = 0.2;                        # Малый параметр при старшей производной
a, b = 0, 1;                    # Область по X
t₀, T = 0, 0.28;                # Область по T
N, M = 50, 80;                  # Кол-во разбиений по X, T
h = (b-a)/N;                    # шаг по X
τ = (T-t₀)/M;                   # шаг по T
Xₙ = [a  + n*h for n in 0:N];   # Сетка по Х
Tₘ = [t₀ + m*τ for m in 0:M];   # Сетка по Т
qₙ =     qf.(Xₙ);               # Сеточные значения коэффициента линейного усиления
ulₘ=    u_l.(Tₘ);               # Сеточные значения левого  ГУ
urₘ=    u_r.(Tₘ);               # Сеточные значения правого ГУ
u₀ = u_init.(Xₙ);               # Начальные условия
nothing #hide

# Все массивы передаются внутрь функции [`solve`](@ref) полностью, вместе с граничными точками.
# Внутри, они локально модифицируются, и на вход
# [`NonLinearReactionAdvectionDiffusionWithFrontData.directRP`](@ref),
# [`NonLinearReactionAdvectionDiffusionWithFrontData.∂directRP_∂y`](@ref)
# подаются без крайних точек.
u, XX, TP = solve(u₀, Xₙ, N, Tₘ, M, ε, ulₘ, urₘ, qₙ);
nothing #hide


# ## Генерация априорной информации
#
# Здесь у нас все просто, сетка статическая, жизнь прекрасна.
ϕl      = phidetermination(qₙ, ulₘ, Xₙ, N, Tₘ, M);                      # Левый вырожденный корень
ϕr      = phidetermination(qₙ, urₘ, Xₙ, N, Tₘ, M, reverseX = true);     # Нужно сигнализировать, о интегрировании в
                                                                        # обратном направлении вдоль оси ``X``.
                                                                        # Ответ нам вернут в обычном направлении.
ϕ       = Φ(ϕl, ϕr, N, M);                                              # Серединный корень
f1_data = f1(ϕ, u, Xₙ, N, M);                                           # Положение переходного слоя
f2_data = f2(f1_data, u, Xₙ, N, M);                                     # Значение функции на переходном слое
nothing # hide
